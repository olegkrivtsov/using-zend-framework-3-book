# Работа с сессиями {#session}

В этой главе вы узнаете о *сессиях*. HTTP является протоколом без сохранения состояния (stateless),
так что два HTTP-запроса по умолчанию не могут обмениваться данными. Сессии PHP позволяют обойти
эту проблему путем сохранения данных во время одного запроса страницы и извлечения позже, во время
другого. Например, можно запомнить, что пользователь залогинился на сайте, и, когда он зайдет на
сайт в следующий раз, отобразить персонализированную веб-страницу. Zend Framework 3 использует
сессии внутренне, но, кроме того, предоставляет удобную обертку для них, так что вы не будете
напрямую обращаться к суперглобальному массиву `$_SESSION`.

Компоненты ZF3, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Session`                 | Реализует обертку PHP-сессий.                                 |
|--------------------------------|---------------------------------------------------------------|

## Сессии PHP

Для начала немного теории о том, что такое сессии. В PHP они работают следующим образом:

  * когда посетитель сайта открывает сайт впервые, PHP задает cookie [^cookie] в клиентском браузере.
  * веб-сайт может сохранить в сессию любую информацию с помощью специального суперглобального массива `$_SESSION`.
    Сохраненные в сессию данные хранятся на сервере в виде дисковых файлов.
  * когда этот же посетитель сайта снова открывает веб-сайт, браузер отправляет сохраненные cookie на сервер. Таким
    образом PHP определяет, что это тот же самый пользователь и снова загружает данные о сессии в массив `$_SESSION`.  

[^cookie]: Cookie в HTTP - это небольшой фрагмент данных, отправленный веб-сайтом и хранящийся в браузере
пользователя в то время, как он просматривает сайт. Cookie используются для сохранения какого-то состояния
между HTTP-запросами.

С точки зрения разработчика PHP-приложения, работать с сессиями просто. Сперва вы инициализируете сессию, вызвав
функцию `session_start()`. Затем воспользуйтесь суперглобальным массивом `$_SESSION` для задания/извлечения данных сессии.
Например, для сохранения каких-либо данных в сессию, используйте следующий код:
    
{line-numbers=off,lang=php}
~~~
session_start();
$_SESSION['my_var'] = 'Some data';
~~~

Чтобы затем извлечь данные из сессии, используйте данный код:

{line-numbers=off,lang=php}
~~~
session_start();
if (isset($_SESSION['my_var']))
    $sessionVar = $_SESSION['my_var'];
else 
    $sessionVar = 'Some default value';
~~~

Для очистки данных используйте функцию PHP `unset()` как показано ниже:

{line-numbers=off,lang=php}
~~~
unset($_SESSION['my_var']);
~~~

Обратите внимание, PHP-сессии не вечны (срок их действия рано или поздно заканчивается: тогда, когда заканчивается
срок действия cookie пользователя, либо когда PHP-движок очищает файлы хранилища сессии). То, как долго будет длиться
сессия, определяется в файле конфигурации *php.ini*. С помощью функции `ini_set()` возможно переопределить стандартные 
параметры срока действия, как показано ниже:

{line-numbers=off,lang=php}
~~~
// Задаем время "жизни" cookie сессии (в секундах), равное 1 часу.
ini_set('session.cookie_lifetime', 60*60*1);

// Храним данные сессии на сервере до 1 месяца.
ini_set('session.gc_maxlifetime', 60*60*24*30);
~~~

В *php.ini* также существует несколько других, расширенных настроек конфигурации PHP, связанной с сессиями.
Так как ими пользуются редко, мы не будем их рассматривать.

Q> **Итак, если сессии настолько простые, зачем мне использовать предоставляемую Zend Framework 3 обертку?**
Q>
Q> Эта обертка для PHP-сессий полезна, потому что: 
Q>
Q>   * она объектно-ориентирована, что значит, она хорошо подходит для вашего MVC-приложения.
Q>   * ZF3 предоставляет концепцию пространств имен сессии, таким образом, разные модели могут хранить данные без конфликтов имен. 
Q>   * ZF3 предоставляет механизмы безопасности (валидаторы сессии), так что недоброжелателям сложнее взломать и подменить ваши данные сессий. 
Q>   * Использование суперглобального массива `$_SESSION` напрямую не очень хорошая идея, так как это усложняет процесс тестирования сайта. При использовании обертки проще подавать тестовые данные.
Q>   * С помощью классов сессий ZF3 можно реализовать пользовательске хранилища данных сессий (например, можно хранить данные сессий не в файлах, а в базе данных).

## Установка компонента Zend\Session

В ZF3 функциональность сессий реализована в компоненте `Zend\Session`. Если вы еще не установили этот компонент
для своего приложения, сделайте это сейчас с помощью Composer, набрав следующую команду:

~~~
php composer.phar require zendframework/zend-session
~~~

Данная команда скачивает код компонента с GitHub и устанавливает его в каталог `APP_DIR/vendor`. Она также
добавляет информацию об установленном модуле в файл конфигурации `APP_DIR/config/modules.config.php`.

## Менеджер сессий

ZF3 предоставляет специальный сервис `SessionManager`, принадлежащий пространству имен `Zend\Session`. Это
обычный сервис ZF3 и он автоматически регистрируется в менеджере сервисов. Получить экземпляр сервиса 
`SessionManager` в классе фабрики можно с помощью следующего кода:

{line-numbers=off,lang=php}
~~~
// Используем псевдоним для класса SessionManager.
use Zend\Session\SessionManager;

// Извлекаем экземпляр менеджера сессий из менеджера сервисов.
$sessionManager = $container->get(SessionManager::class);
~~~

Итак, что делает `SessionManager`? По правде говоря, он делает все для работы сессии.
Краткое описание его наиболее полезных методов представлено в таблице 15.1 ниже:

{title="Table 15.1. Methods provided by the SessionManager class"}
|------------------------------------|--------------------------------------------------|
| *Метод*                            | *Описание*                                       |
|------------------------------------|--------------------------------------------------|
| `sessionExists()`                  | Проверяет, существует ли сессия и активна ли она в данный момент. | 
|------------------------------------|--------------------------------------------------|
| `start($preserveStorage = false)`  | Запускает сессию (если она еще не запущена).     |
|------------------------------------|--------------------------------------------------|
| `destroy(array $options = null)`   | Завершает сессию.                                |
|------------------------------------|--------------------------------------------------|
| `getId()`                          | Возвращает ID сессии.                            |
|------------------------------------|--------------------------------------------------|
| `setId()`                          | Задает ID сессии.                                |
|------------------------------------|--------------------------------------------------|
| `regenerateId()`                   | Изменяет ID сессии на новый.                     |
|------------------------------------|--------------------------------------------------|
| `getName()`                        | Возвращает имя сессии.                           |
|------------------------------------|--------------------------------------------------|
| `setName()`                        | Переопределяет имя сессии по умолчанию (записанное в *php.ini*). |
|------------------------------------|--------------------------------------------------|
| `rememberMe($ttl = null)`          | Задает время "жизни" cookie-файлов (в секундах). |
|------------------------------------|--------------------------------------------------|
| `forgetMe()`                       | Задает время "жизни" cookie-файлов, равное нулю (срок действия cookie закончится при закрытии браузера). |
|------------------------------------|--------------------------------------------------|
| `expireSessionCookie()`            | Немедленно заканчивает срок действия cookie сессии. | 
|------------------------------------|--------------------------------------------------|
| `isValid()`                        | Выполняет валидаторы сессии.                     |
|------------------------------------|--------------------------------------------------|

Как видите из таблицы выше, `SessionManager` может начать сессию и завершить ее, проверить, существует ли сессия, а также
задать параметры сессии (такие как время действие cookie-данных). Он также предоставляет цепочку валидаторов, которая
может содержать валидаторы сессии (они позволяют предотвратить хакерские атаки на данные сессии).

### Определение конфигурации сессии

Класс `SessionManager` считывает конфигурацию приложения при инициализации, что позволяет удобным способом
задать параметры сессии. Чтобы это сделать, измените файл `APP_DIR/config/autoload/global.php`, как показано
ниже:

{line-numbers=off,lang=php}
~~~
<?php
use Zend\Session\Storage\SessionArrayStorage;
use Zend\Session\Validator\RemoteAddr;
use Zend\Session\Validator\HttpUserAgent;

return [
    // Настройка сессии.
    'session_config' => [
        // Срок действия cookie сессии истечет через 1 час.
        'cookie_lifetime' => 60*60*1,     
        // Данные сессии будут храниться на сервере до 30 дней.
        'gc_maxlifetime'     => 60*60*24*30, 
    ],
    // Настройка менеджера сессий.
    'session_manager' => [
        // Валидаторы сессии (используются для безопасности).
        'validators' => [
            RemoteAddr::class,
            HttpUserAgent::class,
        ]
    ],
    // Настройка хранилища сессий.
    'session_storage' => [
        'type' => SessionArrayStorage::class
    ],
    
    // ...
];
~~~

T> Мы изменяем файл `global.php`, так как сессии могут использоваться любым модулем нашего сайта и не зависят
от среды.

Как видите, конфигурация сессии хранится под тремя ключами:


  * Ключ `session_config` позволяет определить срок действия cookie-файлов, а также срок хранения данных сессии
    на сервере.
    На самом деле, этот ключ может содержать и другие опции сессии, но для простоты мы их пропустим (если хотите 
    переопределить эти опции, обратитесь к документации Zend Framework).
    
  * Ключ `session_manager` позволяет задать валидаторы сессии. Они используются для повышения безопасности. Рекомендуется
    всегда указывать данные валидаторы.
    
  * Ключ `session_storage` позволяет указать класс хранилища сессии. Мы используем класс `SessionArrayStorage`, который
    является хранилищем по умолчанию, и в большинстве случаев его функционала достаточно.

### Делаем менеджер сессий выбираемым по умолчанию

Многие компоненты ZF3 используют менеджер сессий неявно (например, плагин контроллера `FlashMessenger` и помощник представления
используют сессию для сохранения сообщений между HTTP-запросами). Чтобы эти компоненты могли использовать только что настроенный
вами менеджер сессий, нужно сделать его выбираемым *по умолчанию*, инстанцировав как можно раньше. Например, менеджер сессий
можно инстанцировать в методе вашего модуля `onBootstrap()`, как показано ниже:

{line-numbers=off,lang=php}
~~~
<?php
namespace Application;

use Zend\Mvc\MvcEvent;
use Zend\Session\SessionManager;

class Module
{
    //...
    
    /**
     * Этот метод вызывается по завершении самозагрузки MVC. 
     */
    public function onBootstrap(MvcEvent $event)
    {
        $application = $event->getApplication();
        $serviceManager = $application->getServiceManager();
        
        // Следующая строка инстанцирует SessionManager и автоматически
        // делает его выбираемым 'по умолчанию'.
        $sessionManager = $serviceManager->get(SessionManager::class);
    }
}
~~~    

T> Очень важно сделать менеджер сессий выбираемым по умолчанию, иначе вам придется явно передавать его каждому компоненту, который
T> от него зависит, что является довольно скучным занятием. 

## Контейнеры сессий

После того, как вы настроили менеджер сессий, вы можете хранить данные в сессии, извлекать данные из сессии, а также добавлять
данные в сессию. Для этого используются *контейнеры сессий*. Контейнеры сессий реализуются классом `Container`, содержащимся
в пространстве имен `Zend\Session`.

Контейнер сессии может быть использован для сохранения данных в сессию и их извлечения из сессии. Чтобы избежать конфликтов
имен между различными классами, модулями и компонентами, использующими сессии, контейнер позволяет вам указать *пространство
имен*, в котором будут храниться данные. Пространство имен контейнера может содержать символы верхнего и нижнего регистров,
нижние подчеркивания и обратные слеши. Так, например, можно использовать такие имена, как "Session\ContainerName", "session_container_name" 
и "SessionContainerName".

I> Контейнеры сессий тесно работают с менеджером сессий. Когда вы создаете контейнер, он автоматически вызывает 
I> метод менеджера `start()`, тем самым запуская и инициализируя сессию.

Теперь давайте начнем использовать контейнеры. Контейнер можно создать двумя эквивалентными способами: либо инстанцировать
контейнер вручную, либо позволить сделать это фабрике. Мы рекомендуем второй, более простой способ.

### Способ 1. Инстанцирование контейнера сессий вручную

Можно просто создать контейнер сессий с помощью оператора `new`, но нужно передать экземпляр
менеджера сессий в конструктор контейнера:

{line-numbers=off,lang=php}
~~~
use Zend\Session\Container;

// Мы предполагаем, что переменная $sessionManager является экземпляром менеджера сессий.
$sessionContainer = new Container('ContainerNamespace', $sessionManager);
~~~

Таким образом, перед созданием контроллера убедитесь, что вы внедрили менеджер сессий в контроллер, сервис или в другой
компонент, в котором вам нужно создать контейнер.

### Способ 2. Создание контейнера сессий с использованием фабрики

Этот способ эквивалентен первому, однако контейнер сессий создается фабрикой.
Вам нужно просто зерагистрировать нужные вам пространства имен контейнеров. Для
этого добавьте ключ `session_containers` в файл `module.config.php`, как показано ниже:

{line-numbers=off,lang=php}
~~~
<?php
return [
    // ...
    'session_containers' => [
        'ContainerNamespace'
    ],
];
~~~

Под этим ключом вы можете перечислить допустимые имена контейнеров. Имя контейнера выбираете вы сами, только убедитесь, что оно уникально среди остальных имен сервисов.

Как только вы зарегистрировали имя контейнера (или несколько имен контейнеров), вы можете создать контейнер и начать работать с ним.
Как правило, это делается в классе фабрики с помощью менеджера сервисов:

{line-numbers=off,lang=php}
~~~
// Переменная $container является менеджером сервисов.
$sessionContainer = $container->get('ContainerNamespace');
~~~

Как видите, контейнер сессий извлекается из менеджера сервисов по его зарегистрированному имени.

### Сохранение данных в сессию с помощью контейнера сессий

После создания контейнера сессий, вы можете сохранять в него данные следующим образом:

{line-numbers=off,lang=php}
~~~
$sessionContainer->myVar = 'Some data';
~~~

Чтобы извлечь данные из контейнера сессий, воспользуйтесь данным кодом:

{line-numbers=off,lang=php}
~~~
if(isset($sessionContainer->myVar))
    $myVar = $sessionContainer->myVar;
else
    $myVar = null;
~~~

Для удаления данных из сессии используйте следующий код:

{line-numbers=off,lang=php}
~~~
unset($sessionContainer->myVar);
~~~

T> За практическими примерами использования контейнеров сессий, пожалуйста, обратитесь к разделу [Реализация многошаговых форм](#multi-step-forms)

## Выводы

Сессии в PHP - это полезный механизм, который позволяет хранить какие-либо данные между запросами страниц. PHP-движок хранит 
данные сессии на сервере в виде файлов и использует cookie браузера, чтобы в следующий раз идентифицировать того же посетителя
сайта и загрузить в память его данные сессии. Так, например, можно запомнить пользователя и показывать для него персонализированные
страницы. Сессия не длится вечно - срок ее действия заканчивается через какое-то время.

Zend Framework предлагает удобную обертку для PHP-сессий. С ее помощью можно хранить данные в контейнерах сессии объектно-ориентированным
способом. ZF3 также предоставляет механизмы безопасности, позволяющие автоматически валидировать сессию и предотвращать хакерские атаки.
