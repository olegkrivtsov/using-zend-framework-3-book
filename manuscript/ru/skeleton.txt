# Скелетное приложение {#skeleton}

Zend Framework 3 предоставляет вам так называемое скелетное приложение ("skeleton application"), чтобы
упростить создание новых вебсайтов с нуля. В этой главе мы рассмотрим, как установить скелетное приложение
и как создать виртуальный хост Apache. Рекомендуется также обратиться к  
[Приложению A. Настройка среды веб разработки](#devenv) перед тем как читать эту главу.

## Загрузка Zend Skeleton Application

Скелетное приложение - это простой вебсайт на основе ZF3, который содержит основные необходимые вещи для
создания собственных вебсайтов. 

Код скелетного приложения хранится на хостинге GitHub и публично доступен по [данной ссылке](https://github.com/zendframework/ZendSkeletonApplication).
Однако вы обычно не загружаете код скелетного приложения напрямую, вместо этого вы используете менеджер зависимостей [Composer](http://getcomposer.org/) 
как показано далее.

Сначала вам нужно получить последнюю версию Composer. Вы делаете это с помощью следующих команд:

```
cd ~

php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"

php composer-setup.php

php -r "unlink('composer-setup.php');"
```

Команды выше меняют текущую директорию на вашу домашнюю директорию, загружают скрипт инсталятора `composer-setup.php` в
рабочую директорию, запускают его, и, наконец, удаляют инсталятор. 

T> Как только вы выполнили команды выше, вы должны обнаружить файл `composer.phar` в вашей рабочей директории.

Теперь запустите следующую команду из терминала:

```
php composer.phar create-project -sdev zendframework/skeleton-application helloworld
```

Команда, приведенная выше, загружает Zend Skeleton Application в директорию `helloworld` и запускает его 
итерактивный установщик. Теперь вы должны ответить на несколько вопросов типа "да/нет", нажимая на клавиши
`y` or `n`, а затем нажимая клавишу Enter. Ваши ответы помогут установщику определить, какие зависимости
необходимо установить. Если вы не знаете что отвечать, нажимайте 'n' (нет); вы сможете установить дополнительные
зависимости позже в любое время.

Для начала, вы можете ответить на вопросы следующим образом:

```
    Do you want a minimal install (no optional packages)? Y/n
n

    Would you like to install the developer toolbar? y/N
n

    Would you like to install caching support? y/N
n

    Would you like to install database support (installs zend-db)? y/N
n

    Would you like to install forms support? y/N
y
    Will install zendframework/zend-mvc-form (^1.0)
    When prompted to install as a module, select application.config.php or modules.config.php

    Would you like to install JSON de/serialization support? y/N
n

    Would you like to install logging support? y/N
n

    Would you like to install MVC-based console support? (We recommend migrating to zf-console, symfony/console, or Aura.CLI) y/N
n

    Would you like to install i18n support? y/N
n

    Would you like to install the official MVC plugins, including PRG support, identity, and flash messages? y/N
n
    Will install zendframework/zend-mvc-plugins (^1.0.1)
    When prompted to install as a module, select application.config.php or modules.config.php

    Would you like to use the PSR-7 middleware dispatcher? y/N
n

    Would you like to install sessions support? y/N
n
    Will install zendframework/zend-session (^2.7.1)
    When prompted to install as a module, select application.config.php or modules.config.php

    Would you like to install MVC testing support? y/N
n
    Will install zendframework/zend-test (^3.0.1)

    Would you like to install the zend-di integration for zend-servicemanager? y/N
n
```

Как только вы ответили на вопросы, установщик загрузит и установит все необходимые пакеты и спросит вас,
в какие файлы конфигурации вы бы хотели внедрить информацию об установленных модулях. Когда вас спросят,
напечатайте '1' и нажмите клавишу Enter:

```
 Please select which config file you wish to inject 'Zend\Form' into:
  [0] Do not inject
  [1] config/modules.config.php
  [2] config/development.config.php.dist
  Make your selection (default is 0):1

  Remember this option for other packages of the same type? (y/N) y
```

Затем установщик спросит вас, хотите ли вы удалить существующие файлы контроля версий из проекта. Так как
вы вероятно будете хранить свое веб-приложение в своей собственной системе контроля версий (такой как Git) и вам не нужны
текущие файлы контроля версий, напечатайте 'y' и нажмите клавишу Enter:

```
Do you want to remove the existing VCS (.git, .svn..) history? [Y,n]? y
```

Теперь скопируйте файл `composer.phar` в директорию `helloworld`:

```
cp composer.phar helloworld
```

И наконец последний и очень важный шаг - включение *режима разработки (development mode)* путем ввода следующих команд:

~~~
php composer.phar development-enable
~~~ 

I> Режим разработки обычно используется когда вы *разрабатываете* свое приложение. Когда вы включаете режим разработки,
I> создаются дополнительные конфигурационные файлы в директории `config` вашего приложения. В этом режиме 
I> ваше приложение может опционально загрузить дополнительные модули "для разработки". Кеширование конфигурации также 
I> отключается в режиме разработки, позволяя вам изменить файлы конфигурации и увидеть эти изменения немедленно
I>
I> Когда вы закончите разработку, вы можете включить *производственный (production)* режим, введя следующую команду:
I> 
I> `php composer.phar development-disable`

Поздравления! Тяжелая работа сделана. Теперь давайте заглянем в директорию `helloworld`.


## Типичная структура директории

Любой веб-сайт, основанный на ZF3 (включая и скелетное приложение) организован одним и тем же рекомендуемым способом.
Конечно, вы можете сконфигурировать свое приложение, чтобы оно использовало другую структуру директорий, но это может
усложнить поддержку вашего веб-сайта другими людьми, которые не знакомы с таким расположением директорий.

Давайте бегло взглянем на типичную структуру директорий (см. рис. 2.1):

![Рис. 2.1. Типичная структура директорий](../en/images/skeleton/skeleton_dir_structure.png)

Как вы видите, в корневом каталоге (далее мы будем называть его `APP_DIR`)
находятся несколько файлов:

* `composer.json` - JSON-файл конфигурации Composer.

* `composer.lock` - файл, содержащий информацию о пакетах, установленных через Composer.

* `composer.phar` - исполняемый PHP-архив, содержащий код менеджера зависимостей Composer.

* `docker-compose.yml` и `Docker` - вспомогательные файлы, используемые в том случае, если вы пользуетесь
  инструментом управления контейнерами [Docker](https://www.docker.com). 
  Использование Docker в этой книге мы рассматривать не будем.

* `LICENSE.txt` - текстовый файл, содержащий лицензию ZF3(вы могли прочитать ее в разделе
  [Введение в Zend Framework 3](#intro)).
  Не удаляйте и не изменяйте этот файл, так как это нарушает лицензию. 
  
* `README.md` - текстовый файл, содержащий краткое описание скелетного приложения. Как правило,
  вы будете заменять содержимое этого файла информацией о вашем сайте: его названии, что он делает,
  как его установить.
   
* `TODO.md` - вспомогательный файл, который можно безопасно удалить.   
  
* `Vagrantfile` - вспомогательный файл, содержащий настройки для [Vagrant](https://www.vagrantup.com/), менеджера
  виртуальной среды разработки. Вы можете игнорировать этот файл, если не знаете, что такое Vagrant. В этой книге мы не будем использовать Vagrant.

Также у нас есть несколько подкаталогов:

Каталог `config` содержит файлы конфигурации приложения.

Каталог `data` содержит данные, которые может создать ваше приложение; он также может содержать кэш, используемый, чтобы ускорить работу Zend Framework.

Каталог `module` содержит все модули приложения. На данный момент у нас есть 
один единственный модуль `Application`. `Application` - это главный модуль вашего сайта.
Вы также можете добавить сюда другие модули, если хотите. Мы поговорим о
модулях чуть позже.

Каталог `vendor` содержит файлы сторонних библиотек, включая файлы библиотеки Zend Framework 3.
Как правило, этот каталог занят Composer'ом.

Каталог `public` содержит данные, доступные пользователю. Как вы видите, пользователи в основном будут
взаимодействовать с `index.php`, который также называется *точкой входа* вашего сайта)

I>У вашего сайта будет одна точка входа, *index.php*, потому что это безопаснее, чем
I>разрешать всем иметь доступ к вашим PHP-файлам.

Внутри каталога `public` вы также найдете скрытый файл `.htaccess`. Его главной целью
является определение правил перезаписи URL.

Каталог `public` содержит несколько подкаталогов, также доступных пользователям:

*  подкаталог `css` содержит все общедоступные CSS-файлы;
*  подкаталог `fonts` содержит веб-шрифты данного приложения;
*  подкаталог `img` содержит общедоступные изображения (*.JPG, *.PNG, *.GIF, *.ICO, и т.д.);
*  подкаталог `js` хранит общедоступные JavaScript-файлы, используемые вашими веб-страницами. 
  Обычно здесь хранятся файлы [jQuery](http://jquery.com/), но вы также можете разместить здесь свои JavaScript-файлы.        

Q> **Что такое библиотека jQuery?**
Q> 
Q> jQuery - это библиотека JavaScript, созданная, чтобы упростить клиентские скрипты HTML-страниц.
Q> Механизм выбора jQuery позволяет легко прикрепить обработчик событий к определенным HTML-элементам,
Q> что сильно упрощает создание интерактивных HTML-страниц.
  
Так как Zend Skeleton Application хранится на GitHub, внутри структуры каталогов вы можете найти
скрытый файл`.gitignore`. Это файлы системы контроля версий [GIT](http://git-scm.com/). 
Вы можете игнорировать их (или даже удалить, если не собираетесь хранить ваш код в репозитории GIT).

## Зависимости приложения

Зависимость - это сторонний код, используемый вашим приложением. Например, Zend Framework 3 является зависимостью для вашего сайта.

В Composer'е любая библиотека называется *пакетом*. Все пакеты, устанавливаемые Composer'ом
регистрируются  на сайте [Packagist.org](https://packagist.org/) site. 
Через Composer вы можете идентифицировать пакеты, необходимые вашему приложению и скачать и установить их автоматически.

Зависимости скелетного приложения объявлены в файле `APP_DIR/composer.json` (см. ниже):

{line-numbers=off,lang=text, title="Contents of composer.json file"}
~~~
{
    "name": "zendframework/skeleton-application",
    "description": "Skeleton Application for Zend Framework zend-mvc applications",
    "type": "project",
    "license": "BSD-3-Clause",
    "keywords": [
        "framework",
        "mvc",
        "zf2"
    ],
    "homepage": "http://framework.zend.com/",
    "minimum-stability": "dev",
    "prefer-stable": true,
    "require": {
        "php": "^5.6 || ^7.0",
        "zendframework/zend-component-installer": "^1.0 || ^0.3 || ^1.0.0-dev@dev",
        "zendframework/zend-mvc": "^3.0.1",
        "zfcampus/zf-development-mode": "^3.0",
        "zendframework/zend-mvc-form": "^1.0",
        "zendframework/zend-mvc-plugins": "^1.0.1",
        "zendframework/zend-session": "^2.7.1"
    },
    "autoload": {
        "psr-4": {
            "Application\\": "module/Application/src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "ApplicationTest\\": "module/Application/test/"
        }
    },
    "extra": [],
    "scripts": {
        "development-disable": "zf-development-mode disable",
        "development-enable": "zf-development-mode enable",
        "development-status": "zf-development-mode status",
        "serve": "php -S 0.0.0.0:8080 -t public/ public/index.php"
    }
}
~~~

Q> **Что такое JSON?**
Q>
Q>JSON (JavaScript Object Notation), - формат файлов, основанный на тексте, используемый 
Q>для читаемого представления простых структур и многомерных ассоциативных массивов. Хотя
Q>JSON произошел от JavaScript, он используется в PHP и других языках из-за его
Q>удобного хранения данных конфигурации. 

В этом файле мы видим базовую информацию о скелетном приложении (его имя,
описание, лицензию, ключевые слова и главную страницу). В будущем, при разработке сайтов,
как правило, вы будете изменять эту информацию. Эта информация необязательна, так что
вы можете вовсе удалить ее, если вы не планируете развертывать ваше веб-приложение в каталоге `Packagist`.

Сейчас нас интересует ключ `require`. Он содержит определения зависимостей 
для нашего приложения. Как видим, нам нужен PHP-движок версии 5.6 или новее и 
несколько компонентон Zend Framework, такие как `zend-mvc`, `zend-form` и др.

Информации, содержащейся в файле `composer.json`, достатончно, чтобы обнаружить зависимости,
загрузить и установить их в подкаталог `vendor`. Если вы когда-либо решите, что вам нужно
установить другую зависимость, вы можете сделать это изменив `composer.json` и добавив в него
свою зависимость, а затем написав следующие команды из вашей командной строки:

{line-numbers=off}
~~~
php composer.phar self-update
php composer.phar install
~~~

Эти команды обновят Composer до последней доступной версии, а затем установят
ваши зависимости. Кстати, Composer не устанавливает для вас PHP, он лишь убеждается
в том, что PHP имеет подходящую версию - если это не так, вы увидите предупреждение.

Если вы посмотрите в подкаталог `vendor` вы увидите, что он содержит множество файлов.
Файлы Zend Framework 3 могут быть найдены в каталоге `APP_DIR/vendor/zendframework/`
(рисунок 2.2). 

![Рисунок 2.2. Каталог Vendor](../en/images/skeleton/vendor_dir.png)

I> В некоторых других фреймворках используется другой (также удобный) способ установки зависимостей.
I> Вы просто скачиваете библиотеку зависимостей архивом, распаковываете архив и помещаете куда-нибудь 
I> в структуру каталогов (обычно в каталог `vendor`). Такой подход использовался Zend Framework 1.
I> Но в Zend Framework 3 рекомендуется устанавливать зависимости через Composer.

## Виртуальный хост Apache

Теперь мы почти готовы к запуску нашего сайта! Последним, что мы сделаем,
будем настройка виртуального хоста Apache. Термин "виртуальный хост"
означает, что вы можете держать несколько сайтов на одном компьютере. 
Виртуальные сайты отличаются доменным именем (как например, `site.mydomain.com` и `site2.mydomain.com`) 
или номером порта (как `localhost` и `localhost:8080`). Виртуальные хосты
работают прозрачно для пользователей сайта, то есть, они не будут знать, на одной 
машине работают сайты или же на нескольких.

На данный момент наше скелетное приложение находится в домашнем каталоге. Чтобы оповестить о нем
Apache, нам нужно изменить файл виртуального хоста.

I> Файл виртуального хоста может находиться в другом месте, это зависит от вашей операционной системы. 
I> Например, в Linux Ubuntu он расположен в файле`/etc/apache2/sites-available/000-default.conf`.
I> Для информации о виртуальных хостах, касающейся ОС и серверов, смотрите [Приложение A. Организация среды веб-разработки](#devenv).

Теперь внесем изменения в стандартный файл виртуального хоста, чтобы он выглядел, как представлено ниже: 

{line-numbers=on,lang=text, title="Virtual host file"}
~~~
<VirtualHost *:80>
    ServerAdmin webmaster@localhost

    DocumentRoot /home/username/helloworld/public
    
	<Directory /home/username/helloworld/public/>
        Options Indexes FollowSymLinks MultiViews
        AllowOverride All
        Require all granted
    </Directory>

    ErrorLog ${APACHE_LOG_DIR}/error.log

    # Possible values include: debug, info, notice, warn, error, crit,
    # alert, emerg.
    LogLevel warn

</VirtualHost>
~~~

Строка 1 указывает Apache слушать все (*) IP-адреса с портом 80.

Строка 2 определяет электронный адрес вебмастера. Если с сайтом что-то случится,
Apache вышлет оповещение на этот адрес. Вы можете ввести здесь ваш e-mail.

Строка 4 определяет корневой каталог документов (`APP_DIR/public`). Все хранящиеся
тут файлы и каталоги будут доступны пользователям. Следует установить здесь
абсолютный пусть к каталогу `public` скелетного приложения.
Таким образом, каталоги и файлы внутри `public` (такие как `index.php`, `css`, `js` и др.)
будут доступны, в то время как каталоги и файлы над этой директорией `public` (такие как 
`config`, `module` и др.) будут недоступны пользователям, что повышает
безопасность сайта.


Строки 6-10 определяют правила для корневого каталога документов (`APP_DIR/public`). Эти правила
переопределяют правила, упомянутые выше. Например, директива `AllowOverride All` позволяет
определять любые правила в файле `.htaccess`. Директива `Require all granted` делает сайт
доступным для всех.

Строка 12 определяет путь к файлу `error.log`, который может быть использован для устранения возможных
ошибок в коде вашего сайта. Строка 16 определяет используемый уровень логирования (уровень `warn` значит,
что предупреждения и ошибки будут записываться в лог).

Строки 14-15 являются комментариями и игнорируются Apache. Вы помечаете комментарии 
символом (#). 

W> Zend Framework 3 использует модуль перезаписи URL Apache' для перенаправления 
W> пользователей на скрипт входа вашего сайта. Пожалуйста, убедитесь, что у
W> вашего веб-сервера включен модуль `mod_rewrite`. Инструкции о том, как его подключить, вы можете
W> найти в [Приложение А. Организация среды веб-разработки](#devenv).

T> После изменения файла конфига не забудьте перезапустить Apache, чтобы сохранить ваши изменения.

## Открытие веб-сайта в браузере

Чтобы открыть сайт, наберите "http://localhost" в адресной строке браузера и нажмите Enter.
Рисунок 2.3 показывает сайт в действии.

На появившейся странице сверху вы можете видеть меню навигации. На данный момент 
панель навигации состоит из единственной ссылки *Home*.
Под панелью навигации находится заголовок "Welcome to Zend Framework". 
Под ним вы найдете некоторые советы для новичков по разработке приложений с ZF3.

![Рисунок 2.3. Zend Skeleton Application](../en/images/skeleton/zend_skeleton_default_view.png)

## Создание проекта NetBeans

Теперь, когда у нас есть настроенное и работающее скелетное приложение, мы захотим
что-нибудь поменять в нем в будущем. Чтобы без проблем управлять структурой каталогов, изменять
файлы и отлаживать сайт, обычно используют интегрированную среду разработки (Integrated Development Environment или IDE). 
В этой книге мы используем среду разработки NetBeans. (О том, как ее установить, читайте
в [Приложение A. Организация среды веб-разработки](#devenv)). 

Чтобы создать проект для нашего скелетного приложения в NetBeans, запустите среду разработки и выберите
*Файл->Создать проект...*. Откроется диалоговое окно *Новый проект* (см. рисунок 2.4).

![Рисунок 2.4. Создание проекта в NetBeans - страница выбора проекта](../en/images/skeleton/netbeans_create_project.png)

На появившейся странице *Выберите проект*, вам надо выбрать тип проекта - PHP, 
затем в списке справа выбрать *Приложения с существующими исходниками* 
(так как у нас уже есть код скелетного приложения). Затем нажмите кнопку *Далее*, чтобы перейти на 
следующую страницу (см. рисунок 2.5).  

![Рисунок 2.5. Создание проекта в NetBeans - Страница имени и местоположения](../en/images/skeleton/netbeans_create_project_step2.png)

На странице *Имя и местоположение* вам надо ввести путь к вашему коду (например, */home/username/helloworld*),
имя проекта (например, `helloworld`) и указать версию PHP, которую вы используете (PHP 5.6 или новее). 
Версия PHP нужна NetBeans для проверки синтаксиса PHP, которая проверит ваш код на наличие ошибок
и укажет на них. Нажмите кнопку *Далее* для перехода на следующую страницу. (см. рисунок 2.6).

![Рисунок 2.6. Создание проекта в NetBeans - Страница выбора конфигурации](../en/images/skeleton/netbeans_create_project_step3.png)

На странице *Конфигурация запуска*, рекомендуется указать, как вы будете держать ваш сайт (Local Web 
Site) и URL сайта (`http://localhost`). Оставьте поле *Файл индекса* пустым (потому что мы используем `mod_rewrite`,
и пусть к вашему файлу `index.php` на самом деле, скрыт Apache). Если вы видите предупреждающее сообщение 
"Для запуска и отладки проекта из командной строки нужно указать файл индекса", просто проигнорируйте его. 

Нажмите кнопку *Завершить*, чтобы создать проект. Как только проект *helloworld* будет
успешно создан, вы должны будете увидеть окно проекта (см. рисунок 2.7).

![Рисунок 2.7. Окно проекта NetBeans](../en/images/skeleton/netbeans_project_window.png)

В окне проекта располагаются строка меню, панель инструментов, панель
*Проекты*, где перечислены ваши файлы проекта, и в правой части окна
код файла `index.php`.

Больше полезных советов о NetBeans, включая запуск и интерактивную отладку
сайтов с ZF3, смотрите [Приложение Б. Введение в PHP-разработку в среде NetBeans](#netbeans).

T> **Время для материала продвинутого уровня...**
T> 
T> Поздравляем! Вы проделали тяжелую работую по установке и запуску 
T> Zend Skeleton Application, и теперь пришло время отдохнуть и почитать 
T> о некоторых продвинутых вещах в последней части этой главы.

## Файл доступа к гипертексту (.htaccess)

Когда мы говорили о типичных структурах каталогов, мы упомянули файл
`APP_DIR/public/.htaccess`. Теперь попробуем понять, что же он делает. 

Файл `.htaccess` (доступ к гипертексту - hypertext access) - это файл конфигурации
веб-сервера Apache, позволяющий переопределять некоторые глобальные настройки веб-сервера.
Файл `.htaccess` - это конфигурация на уровне каталога, то есть,
он влияет только на принадлежащий ему каталог и все его подкаталоги.

Содержимое файла `.htaccess` представлено ниже:

{line-numbers=on,lang=text}
~~~
RewriteEngine On
# The following rule tells Apache that if the requested filename
# exists, simply serve it.
RewriteCond %{REQUEST_FILENAME} -s [OR]
RewriteCond %{REQUEST_FILENAME} -l [OR]
RewriteCond %{REQUEST_FILENAME} -d
RewriteRule ^.*$ - [L]
# The following rewrites all other queries to index.php. The 
# condition ensures that if you are using Apache aliases to do
# mass virtual hosting or installed the project in a subdirectory,
# the base path will be prepended to allow proper resolution of
# the index.php file; it will work in non-aliased environments
# as well, providing a safe, one-size fits all solution.
RewriteCond %{REQUEST_URI}::$1 ^(/.+)/(.*)::\2$
RewriteRule ^(.*) - [E=BASE:%1]
RewriteRule ^(.*)$ %{ENV:BASE}/index.php [L]
~~~

Строка 1 говорит веб-серверу Apache включить движок перезаписи URL (`mod_rewrite`). Двидок перезаписи изменяет
входящие URL-запросы в зависимости от правил регулярных выражений.
Это позволяет вам связать произвольные URL с вашей внутренней структурой URL любым образом.

Строки 4 - 7 определяют правила перезаписи, которые сообщают веб-серверу, что, если 
клиент (то есть, браузер) запрашивает файл, который существует в корневом каталоге документов,
то следует вернуть содержимое этого файла как HTTP-ответ. Так как у нас есть каталог `public`
внутри корневого каталога документов виртуального хоста, мы позволяем посетителям сайта видеть все файлы 
в каталоге `public`, включая `index.php`, CSS-файлы, JavaScript-файлы и файлы изображений.

Строки 14 - 16 определяют правила перезаписи, которые сообщают Apache, что необходимо делать,
если пользователь запрашивает файл, которого не существует в корневом каталоге документов. В этом случае
пользователя следует перенаправить на `index.php`.

Таблица 2.1 содержит несколько примеров перезаписи URL. Первый и второй URL указывают на
существующие файлы, поэтому `mod_rewrite` возвращает путь к запрашиваемому файлу. URL в третьем
примере указывает на несуществующий файл `htpasswd` (это может быть признаком хакерской атаки),
и, согласно правилам перезаписи, движок возвращает файл `index.php`.

{title="Таблица 2.1. Примеры перезаписи URL"}
|-------------------------------------|-----------------------------------------|
| **Запрашиваемый URL**               | **Перезаписанный URL**                  |
|-------------------------------------|-----------------------------------------|
| `http://localhost/index.php`        | Файл существует; возвращается локальный файл|
|                                     | `APP_DIR/public/index.php`              |
|-------------------------------------|-----------------------------------------|
| `http://localhost/css/bootstrap.css`| Файл существует; возвращается локальный файл| 
|                                     | `APP_DIR/public/css/bootstrap.css`      |
|-------------------------------------|-----------------------------------------|
| `http://localhost/htpasswd`         | Файл не существует; вместо этого возвращается файл|
|                                     | `APP_DIR/public/index.php`              |
|-------------------------------------|-----------------------------------------|

## Блокирование доступа к веб-сайту по IP-адресу

Иногда может понадобиться заблокировать доступ к вашему сайту для всех IP-адресов
кроме вашего. Например, когда вы разрабатываете веб-сайт, вы не хотите, чтобы кто-нибудь
видел вашу незаконченную работу. Кроме того, вы можете не хотеть, чтобы ваш сайт индексировался
Google или другими поисковыми системами.

Чтобы запретить доступ к вашему сайту, вы можете изменить виртуальный хост, добавив в него следующую строку:

{line-numbers=off,lang=text}
~~~
Require ip <ваш ip-адрес>
~~~

Q> **Как мне узнать мой IP-адрес?**
Q>
Q> Вы можете воспользоваться сайтом [http://www.whatismyip.com](http://www.whatismyip.com/),
Q> чтобы узнать свой внешний IP-адрес. Внешний IP-адрес - это адрес, по которому другие
Q> компьютеры в Интернет могут обратиться к вашему сайту.

## Аутентификация HTTP

Возможно, вы захотите разрешить доступ к вашему сайту только определенным пользователям.
Например, когда вы показываете ваш сайт своему начальнику, вы дадите ему логин и пароль
для входа на сайт.

Чтобы разрешить доступ к вашему сайту по логину и паролю, вы можете изменить файл виртуального
хоста, добавив в него следующие строки:

{line-numbers=on,lang=text}
~~~
AuthType Basic
AuthName "Authentication Required"
AuthUserFile /usr/local/apache/passwd/passwords
Require valid-user
~~~

Строка 1 определяет метод аутентификации. Самый распространенный из
них - Basic. Важно, однако, помнить, что базовая аутентификация посылает
пароль от клиента к серверу незашифрованным. Поэтому этот метод не следует 
использовать для уязвимых данных. Apache поддерживает еще один метод
аутентификации: `AuthType Digest`. Этот метод гораздо более безопасный.
Большинство новых браузеров поддерживают этот метод.

Строка 2 определяет текст, который будет отображен при попытке пользователя залогиниться.

Строка 3 определяет файл, где будут храниться пароли. Этот файл нужно создавать
утилитой `htpasswd`.

Строка 4 позволит залогиниться всем, кто корректно ввел пароль.

Чтобы создать файл `passwords`, введите следующую команду:

~~~
htpasswd -c /usr/local/apache/passwd/passwords <username>
~~~

В этой команде вы должны заменить плейсхолдер `<username>` на логин.
Вы можете выбрать временный логин, например "admin". Команда потребует пароль
и затем запишет его в файл:

{line-numbers=off,lang=text}
~~~
# htpasswd -c /usr/local/apache/passwd/passwords <username>
New password: 
Re-type new password: 
Adding password for user <username>
~~~

Когда пользователь пытается зайти на сайт, он видит диалоговое окно с HTTP-аутентификацей (см. рисунок ниже).
Чтобы зайти на ваш сайт, посетителю необходимо ввести корректные логин и пароль.

I> Дополнительную информацию о HTTP-аутентификации вы можете найти в разделе документации Apache
I> [Аутентификация и авторизация](http://httpd.apache.org/docs/current/howto/auth.html)


## Включение нескольких виртуальных хостов

При разработке нескольких сайтов на одной машине, вы захотите создать несколько виртуальных хостов.
Для каждого виртуального хоста вам нужно отдельное доменное имя (например, `site1.mydomain.com`).
Однако если у вас еще нет доменного имени, вы можете использовать вместо этого отдельный порт (см. пример ниже).

{line-numbers=off,lang=text}
~~~
# Listen directive tells Apache to listen requests on port 8080
Listen 8080

<VirtualHost *:8080>
    ...
</VirtualHost>
~~~

Чтобы зайти на сайт, введите в адресной строке браузера: "http://localhost:8080".

T> После изменения файла конфигурации виртуального хоста, нужно перезапустить Apache, чтобы применить изменения.

## Файл Hosts

Когда у вас есть несколько локальных веб-сайтов на разных портах, становится сложно помнить о том,
на каком порте находится определенный сайт. Чтобы избежать такой проблемы, можно использовать
виртуальный хост, основанный на имени и определить псевдоним для вашего сайта в файле `hosts`.

Первым делом измените файл виртуального хоста Apache, чтобы сделать его *основанном на имени*.

{line-numbers=off,lang=text}
~~~
<VirtualHost *:80>
    # Add the ServerName directive
	ServerName site1.localhost	
	...	
</VirtualHost>
~~~

Затем нужно изменить файл `hosts`. Это системный файл, который содержит связи между IP-адресами
и именами хостов. Он содержит текстовые данные, состоящие из IP-адреса в первом текстовом поле и
следующим(и) за ним именем(ами) хоста(ов).

Чтобы добавить псевдоним вашим локальным веб-сайтам, добавьте для каждого
из ваших сайтов строки по образцу ниже.

{line-numbers=off,lang=text}
~~~
127.0.0.1            site1.localhost
~~~

Таким образом, теперь вы сможете просто вводить "site1.localhost" в адресной строке браузера
вместо того, чтобы запоминать номер порта.

I> В Linux, файл hosts находится в `/etc/hosts`.
I> В Windows, этот файл, как правило, находится в `C:\Windows\System32\drivers\etc\hosts`.
I> Чтобы изменять файл, вам нужно обладать плавами администратора. Обратите также внимание, что
I> некоторые антивирусы могут препятствовать изменениям файла hosts, так что вам придется
I> отключить антивирус для изменения файла и после включить его вновь.

I> Если вы купили "реальное" доменное имя (например, `example.com`), вам не нужно
I> изменять файл `hosts`, потому что Apache сможет определить IP-адрес сайта через 
I> систему доменных имен (Domain Name System или DNS). Изменять файл hosts нужно только тогда,
I> когда DNS ничего не знает о доменном имени и не может определить IP-адрес вашего сайта.

## Расширенные сведения о Composer

Ранее в этой главе мы использовали Composer, чтобы установить код библиотек Zend Framework 3.
Теперь вкратце опишем некоторые продвинутые примеры использования Composer'a.

Как мы уже знаем, единственный необходимый ключ в файле `composer.json` это `require`.
Он сообщает, какие пакеты требуются вашему приложению.

{line-numbers=off,lang=text}
~~~
{
    "require": {
        "php": "^5.6 || ^7.0",
        "zendframework/zend-component-installer": "^1.0 || ^0.3 || ^1.0.0-dev@dev",
        "zendframework/zend-mvc": "^3.0.1",
        "zfcampus/zf-development-mode": "^3.0",
        "zendframework/zend-mvc-form": "^1.0",
        "zendframework/zend-mvc-plugins": "^1.0.1",
        "zendframework/zend-session": "^2.7.1"
    }
}
~~~

### Имена и версии пакетов

Имя пакета состоит из двух частей: имени поставщика и имени проекта. Например, имя пакета
"zendframework/zend-mvc" состоит из имени поставщика "zendframework" и имени проекта
"zend-mvc". Другие пакеты от поставщика "zendframework" вы можете найти на сайте
[Packagist.org](https://packagist.org/search/?q=zendframework) (см. рисунок 2.8).

![Рисунок 2.8. Пакеты можно найти на Packagist.org](../en/images/skeleton/packagist_search.png)

Пакет также имеет номер связанной версии. Он состоит из: главного номера, вспомогательного номера,
номера сборки (необязательно) и суффикса (например, b1, rc1; также необязательно). В ключе `require`
мы указываем, какие версии пакета допустимы. Например, "^5.6" означает, что мы можем установить версии новее
5.6, но позднее 6.0. (мы можем установить только те пакеты, которые не нарушают обратную совместимость).
В таблице 2.2 представлены возможные способы указания допустимых версий.


{title="Таблица 2.2. Определения версии пакета"}
|-------------------------|----------------------------------------------------------------------------|
| *Пример определения*    | *Описание*                                                                 |
|-------------------------|----------------------------------------------------------------------------|
| 3.0.1                   | Конкретная версия. В этом примере можно установить только версию 3.0.1.    | 
|-------------------------|----------------------------------------------------------------------------|
| >=3.0.1                 | Эта или более поздние версии могут быть установлены. (3.0.1, 3.2.1, etc.)  |
|-------------------------|----------------------------------------------------------------------------| 
| >3.0.1                  | Только более поздние версии могут быть установлены. (3.0.2 etc.)           |
|-------------------------|----------------------------------------------------------------------------| 
| <=3.0.1                 | Эта или более ранние версии могут быть установлены. (1.0, 1.5, 2.0.0 etc.) |
|-------------------------|----------------------------------------------------------------------------| 
| <3.0.1                  | Только более ранние версии могут быть установлены. (1.0, 1.1, 1.9, etc.)   |
|-------------------------|----------------------------------------------------------------------------| 
| !=3.0.1                 | Все версии, кроме этой, могут быть установлены.                            | 
|-------------------------|----------------------------------------------------------------------------|
| >=3.0,<3.1.0            | Любая версия из этого диапазона может быть установлена.                    |
|-------------------------|----------------------------------------------------------------------------|
| 3.*                     | Любая версия с главным номером 3 может быть установлена (вспомогательный   |
|                         | номер может быть любым).                                                   |
|-------------------------|----------------------------------------------------------------------------|
| ~3.0                    | Любая версия, начиная от 3.0. до версии со следующим главным номером       |
|                         | (эквивалентно >=3.0,<4.0).                                                 | 
|-------------------------|----------------------------------------------------------------------------|
| ^3.0                    | Любая версия, начиная от 3.0. до версии со следующим главным номером       |
|                         | (эквивалентно >=3.0,<4.0). Работает аналогично `~3.0`, но ближе к          |
|                         | семантическому управлению версиями.                                        | 
|-------------------------|----------------------------------------------------------------------------|

### Установка и обновление пакетов

Итак, мы посмотрели, как использовать команду `php composer.phar install` для установки зависимостей. Как только вы
вызываете эту команду, Composer найдет, загрузит и установит зависимости в подкаталог `vendor`.

Q> **Безопасно ли устанавливать зависимости через Composer?**
Q>
Q> Вообще, некоторые люди побаиваются управления зависимостями с помощью Composer'a,
Q> потому что думают, что кто-нибудь может обновить зависимости для всей системы случайно или специально,
Q> нарушив при этом работу веб-приложения. Заметьте, Composer *никогда* не устанавливает их для всей системы,
Q> только в каталог `APP_DIR/vendor/`.

После установки Composer также создает файл `APP_DIR/composer.lock`. Он содержит
актуальные версии установленных пакетов. Если вы снова запустите команду `install`,
Composer столкнется с файлом `composer.lock`, проверит, какие зависимости уже были установлены, и,
так как все пакеты уже установлены, выйдет, ничего не делая.

Теперь предположим, что в какой-то момент времени вышли новые обновления безопасности для ваших пакетов зависимостей.
Вы захотите обновить ваши пакеты для поддержания защиты вашего сайта. Это можно сделать следующей строчкой:

`php composer.phar update`

Если же вы хотите обновить только одну зависимость, напишите ее имя следующим образом:

`php composer.phar update zendframework/zend-mvc`

После команды `update` файл `composer.lock` также обновится.

Q> **Что делать, если я захочу вернуться к предыдущей версии пакета?**
Q>
Q> Если обновление привело к нежелательным проблемам с вашей системой, вы можете откатить ее,
Q> отменив изменения файла `composer.lock` и снова запустив команду `install`.
Q> Отменить изменения `composer.lock` довольно просто, если вы используете систему контроля версий, например, GIT или SVN.
Q> Если вы не хотите использовать систему контроля версий, сделайте резервную копию файла`composer.lock` перед обновлением.

### Добавление новой зависимости

Если вы хотите добавить новую зависимость в приложению, вы можете либо вручную изменить `composer.json`,
либо запустить команду `require`. Например, чтобы установить модуля ORM Doctrine на ваш сайт
(чтобы добавить пакет "doctrine/doctrine-module" к зависимостям приложения), напишите:

`php composer.phar require doctrine/doctrine-module 2.*`

Эта команда изменяет файл `composer.json` и загружает и устанавливает пакет. Мы будем использовать ее позже
в главе [Управление базой данных с Doctrine](#doctrine)

### Виртуальные пакеты

Composer можно использовать для того, чтобы потребовать каких-то дополнительных функций для вашей системы.
Выше мы уже требовали "php:^5.6". Пакет PHP - это виртуальный пакет, представляющий, собственно, сам PHP.
Вам также может понадобиться и другие материалы, например, расширения PHP (см. таблицу 2.3).

{title="Таблица 2.3. Виртуальные пакеты Composer"}
|------------------------------------------------------------------------------------------------------|
| *Пример определения*    | *Описание*                                                                 |
|------------------------------------------------------------------------------------------------------|
| "php":"^5.6"            | Требует версию PHP 5.6 или новее, но не позже 6.0.                         | 
|------------------------------------------------------------------------------------------------------|
| ext-dom, ext-pdo-mysql  | Требует расширения PHP DOM и PDO MySQL.                                    | 
|------------------------------------------------------------------------------------------------------|
| lib-openssl             | Требует библиотеку OpenSSL                                                 | 
|------------------------------------------------------------------------------------------------------|

Вы можете использовать команду `php composer.phar show --platform` для отображения списка доступных для
вашей машины виртуальных пакетов.

### Composer и системы контроля версий

Если вы используете систему контроля версий (например, Git), вам наверняка будет интересно,
что должно там храниться: только код вашего приложения или код приложения плюс все установленные
Composer'ом в каталог `APP_DIR/vendor` зависимости?

В целом, не рекомендуется хранить эти зависимости под контролем версий, потому что это сделает
репозиторий чересчур большим и затруднит его проверку и расширение. Вместо этого под контролем
версий лучше хранить файл `composer.lock`. Этот файл гарантирует, что все будут устанавливать те
же версии зависимостей, что и у вас. Это полезно при коллективной разработке, потому что все
разработчики должны иметь один и тот же код, чтобы избежать нежелательных проблем с неправильными
настройками среды.

Q> **Что если какая-нибудь зависимость будет объявлена устаревшей и удалена с Packagist.org?**
Q>
Q> Вообще, вероятность удаления пакета минимальна. Все пакеты бесплатны и с открытым исходным кодом,
Q> и сообщество пользователей всегда может восстановить зависимость, даже если она была удалена с Packagist.
Q> Кстати, такая же концепция установки зависимостей используется в in Linux (помните менеджеры APT и RPM?) -
Q> а пакеты Linux когда-нибудь терялись?

Но могут возникнуть ситуации, когда вам следует хранить зависимые библиотеки под контролем версий:

* Если вам нужно вносить свои изменения в сторонний код. Например, предположим,
  вам нужно исправить баг в библиотеке, и вы не можете ждать, пока поставщик библиотеки
  исправит его для вас (или он просто не может этого сделать). В этом случае, вам следует
  положить библиотеку под контроль версий, чтобы не потерять сделанные вами изменения.

* Если вы написали модуль (или библиотеку), которую будете многократно использовать, и хотите
  хранить его в каталоге `vendor` без развертывания на *Packagist.org*. Так как вы не можете
  установить этот код с Packagist, его следует хранить под контролем версий.

* Если вы хотите 100%-ную гарантию того, что сторонний пакет не будет утерян. Хотя риск
  этого минимален, некоторым приложениям необходимо быть автономными и не зависеть от
  доступности пакетов на *Packagist.org*.

## Выводы

В этой главе мы скачали код проекта Zend Skeleton Application с GitHub и установили
его через менеджер зависимостей Composer. Мы настроили виртуальный хост Apache так,
чтобы он сообщал веб-серверу о местонахождении корневого каталога документов.

Скелетное приложение демонстрирует рекомендуемую структуру каталогов типичного веб-сайта.
У нас есть каталог `public`, содержащий файлы, доступные пользователю, включая файл точки входа `index.php`,
CSS-файлы, JavaScript-файлы и изображения. Все другие каталоги приложения недоступны пользователям и
содержат конфигурацию приложения, данные и модули.

Во второй части главы мы обсудили некоторые продвинутые настройки Apache. Например, вы можете защитить
ваш сайт паролем и разрешить доступ к нему только с определенным IP-адресов.

Менеджер зависимостей Composer - мощный инструмент для установки зависимостей вашего сайта. Например,
Zend Framework 3 сам по себе может считаться зависимостью. Все пакеты, установленные Composer'ом,
регистрируются в централизованном каталоге на сайте Packagist.org.
