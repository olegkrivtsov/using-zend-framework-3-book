# Как работает веб-сайт {#operation}

В этой главе мы рассмотрим работу типичного веб-приложения на базе Zend Framework 3.
Вы узнаете, как используются пространства имен PHP во избежание конфликтов имен. Вы также
ознакомитесь с такими важными компонентами ZF3 как `Zend\EventManager`, `Zend\ModuleManager` и `Zend\ServiceManager`.
Если вместо изучения теории вы хотите заняться практикой, пропустите эту главу и перейдите к главе [Модель-представление-контроллер](#mvc).

Компоненты ZF3, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                   |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Mvc`                     | Поддержка шаблона "модель-представление-контроллер". Отделяет  |
|                                | бизнес-логику от представления.                                      |
|--------------------------------|---------------------------------------------------------------|
| `Zend\ModuleManager`           | Компонент, ответственный за загрузку и инициализацию модулей веб-приложения. |
|--------------------------------|---------------------------------------------------------------|
| `Zend\EventManager`            | Компонент, обеспечивающий функциональность для инициации событий и обработки событий. |
|--------------------------------|---------------------------------------------------------------|
| `Zend\ServiceManager`          | Реестр всех сервисов, доступных в веб-приложении.             |
|--------------------------------|---------------------------------------------------------------|

## Пространства имен PHP

Когда вы используете классы из разных библиотек (и даже классы из разных компонентов одной библиотеки)
в вашей программе, имена классов могут конфликтовать между собой.
Это значит, что, имея два класса с одинаковыми именами, вы столкнетесь с ошибкой интерпретатора PHP.
Если вы когда-нибудь разрабатывали сайты с Zend Framework 1, вы, возможно, помните *супердлинные*
имена классов вроде `Zend_Controller_Abstract`. Длинные имена использовались для того, чтобы
избежать конфликтов имен между различными компонентами. У каждого компонента был собственный префикс,
например, `Zend_` или `My_`.

Zend Framework 3 для этих целей используют такую особенность языка PHP, как *пространства имен* (namespaces). 
Они позволяют разрешить конфликты имен между компонентами кода и предоставляют вам возможность
существенно сократить эти имена.

Пространство имен - это такой контейнер для группы имен. Вы можете вложить одно пространство имен в другое.
Если класс или функция не определяют пространство имен, они существуют в *глобальном* пространстве имен
(например, глобальному пространству имен принадлежат классы `Exception` и `DateTime`).

Ниже представлен пример определения пространства имен, взятый из компонента *Zend\Mvc*:

{line-numbers=on,lang="php"}
~~~
<?php
namespace Zend\Mvc;

/**
 * Главный класс приложения.
 */
class Application 
{
  // ... элементы класса опущены для простоты ...
}
~~~

I> Как вы можете заметить, в примере выше есть открывающий тег `<?php`, который
I> сообщает PHP-движку, что текст после тега - это PHP-код. В этом примере, где файл содержит
I> только PHP-код (без смешения тегов PHP и HTML), вам не нужно вставлять закрывающий 
I> тег `?>` в конце кода. Более того, это не рекомендуется, и может вызвать нежелательные
I> последствия, если вы случайно добавите какие-либо символы после тега `?>`.

В Zend Framework 3, все классы принадлежат пространству имен верхнего уровня *Zend*.
Строка 2 определяет пространство имен *Mvc*, которое вложено в *Zend*,
и все классы этого компонента (включая класс `Application`, представленный в этом
примере в строках 7-10) принадлежат этому пространству имен. Вложенные пространства имен
разделяются обратным слешем. ('\\').

В других частях кода, вы ссылаетесь на класс `Application`, используя
его полностью определенное имя:

{line-numbers=off,lang="php"}
~~~
<?php
$application = new \Zend\Mvc\Application;
~~~

I> Обратите внимание на первый обратный слеш в имени `\Zend\Mvc\Application`
Если имя класса начинается с обратного слеша, значит, это имя - полностью определенное.
Если имя класса возможно специфировать относительно текущего пространства имен, этот
обратный слеш не используется.

Также можно использовать *псевдонимы (aliases)* (короткие имена классов) с помощью
оператора `use`:

{line-numbers=off,lang="php"}
~~~
<?php
// Определяем псевдоним в начале сайта.
use Zend\Mvc\Application;

// Затем используем короткое имя класса.
$application = new Application;
~~~

T> Хотя псевдонимы позволяют использовать короткие имена классов,
T> использовать их необязательно - вы точно также можете обращаться к классу
T> по его полностью определенному имени.

Каждый PHP-файл приложения, как правило, определяет пространство имен
(кроме входного файла *index.php* и файлов конфигурации, они обычно этого не делают).
Например, главный модуль вашего сайта, *Application*, определяет свое собственное
пространство имен с одноименным названием:

{line-numbers=off,lang="php"}
~~~
<?php
namespace Application;

class Module 
{
    // ... элементы класса опущены для простоты ...
}
~~~

## Интерфейсы PHP

*Интерфейсы* в PHP позволяют определять, как будет вести себя класс без необходимости
описания этого поведения. Это также называется *контрактом*:  при создании интерфейса
класс соглашается с условиями контракта.

Интерфейсы широко распространены в Zend Framework 3. Например, класс `Application` реализует интерфейс
`ApplicationInterface`, определяющий методы, которые должен иметь каждый класс приложения:

{line-numbers=off,lang="php"}
~~~
<?php 
namespace Zend\Mvc;

interface ApplicationInterface
{
    // Возвращает менеджер сервисов.
    public function getServiceManager();

    // Возвращает объект HTTP-запроса.
    public function getRequest();

    // Возвращает объект HTTP-ответа.
    public function getResponse();

    // Запускает приложение.
    public function run();
}
~~~

Как видно из примера выше, интерфейс определяется с использованием ключевого слова `interface`, почти
так же, как определяется стандартный PHP-класс. Интерфейс, как и обычный класс, определяет методы.
Однако, интерфейс не предоставляет реализацию методов. Как видно из определения интерфейса `ApplicationInterface`
выше, каждое приложение с этим интерфейсом будет иметь метод `getServiceManager()` для возвращения
менеджера сервисов (о менеджере сервисов мы поговорим позже в этой главе), методы `getRequest()` и `getResponse()`
для возвращения соответственно HTTP-запроса и HTTP-ответа и метода `run()` для запуска приложения.


I> В Zend Framework 3 к именам интерфейсов принято добавлять суффикс `Interface`, например,
`ApplicationInterface`. 

Класс, реализующий интерфейс, называется *конкретным* классом. Конкретный класс `Application`
реализует `ApplicationInterface`, что означает, что он содержит реализацию методов, определенных
интерфейсом:

{line-numbers=off,lang="php"}
~~~
<?php 
namespace Zend\Mvc;

class Application implements ApplicationInterface
{
  // Реализация методов интерфейса
   
  public function getServiceManager() 
  {
    // Некая реализация...
  }

  public function getRequest() 
  {
    // Некая реализация...
  }

  public function getResponse() 
  {
    // Некая реализация...
  }

  public function run() 
  {
    // Некая реализация...
  }
}
~~~ 

Конкретный класс `Application` использует ключевое слово `implements`, чтобы показать, 
что он содержит реализацию всех методов интерфейса `ApplicationInterface`.
Класс `Application` также может иметь и другие методы, которые не являются
частью интерфейса.

Графически отношения классов изображаются с помощью диаграмм наследования. 
На рисунке 3.1 представлена такая диаграмма для класса `Application`. Стрелки
ведут от производного класса к родительскому.

![Рисунок 3.1. Диаграмма наследования класса Application](../en/images/operation/Application.png)
	
## Автозагрузка классов в PHP

Веб-приложение состоит из множества PHP-классов,  и каждый класс, как правило, располагается
в отдельном файле. Это приводит к необходимости *включения (including)* файлов.

Предположим, например, что у нас есть файл с именем *Application.php*, который
содержит определение класса `\Zend\Mvc\Application` из предыдущего раздела.
Перед тем как создать экземпляр этого класса где-либо в своем коде, вы должны
включить содержимое файла *Application.php* (это можно сделать с помощью оператора
`require_once`, передав ему полный путь к файлу):

{line-numbers=off,lang="php"}
~~~
<?php
require_once "/path/to/zend/lib/Application.php";

use Zend\Mvc\Application;

$application = new Application;
~~~

С увеличением размера вашего приложения включение каждого необходимого файла
может вызывать трудности. Сам Zend Framework 3 состоит из сотен файлов, и 
загружать целую библиотеку и все ее зависимости таким образом довольно сложно.
Более того, при запуске кода интерпретатору PHP потребуется процессорное время для
обработки каждого включенного файла, даже если вы не создавали экземпляр его класса.

Для решения этой проблемы в PHP была введена опция автозагрузки классов.
Функция `spl_autoload_register()` позволяет вам зарегистрировать функцию
*автозагрузки*. Для сложных сайтов можно даже создать несколько функций
автозагрузки, объединенные в стек.

Если интерпретатор PHP во время выполнения скрипта сталкивается с именем класса,
которое еще не было определено, он вызывает все зарегистрированные функции 
автозагрузки по порядку до тех пор, пока какая либо функция автозагрузки не включит класс. 
Если же ни одна из функций автозагрузки не сделает этого, будет выброшена ошибка "not found". 
Это делает возможным "ленивую" загрузку, при которой
интерпретатор обрабатывает определение класса только в момент его вызова - когда он
на самом деле нужен.

Чтобы дать вам представление о том, как выглядит функция автозагрузки, ниже мы
привели ее упрощенную реализацию:

{line-numbers=off,lang="php"}
~~~
<?php
// Функция автозагрузки.
function autoloadFunc($className) 
{
  // Статический массив карты классов.
  static $classMap = [
    '\\Zend\\Mvc\\Application' => '/path/to/zend/dir/Zend/Mvc/Application.php',
    '\\Application\\Module' => '/path/to/app/dir/Application/Module.php',
    //...
  ];

  // Проверяем, находится ли такое имя класса в карте классов.
  if(isset(static::$classMap[$className])) {
    $fileName = static::$classMap[$className];
  
    // Проверяем, существует ли файл и возможно ли его прочитать.
    if (is_readable($filename)) {
      // Подлючаем файл.
      require $filename;
    }
  }
}

// Регистрируем нашу функцию автозагрузки.
spl_autoload_register("autoloadFunc");
~~~

В примере выше мы определяем функцию автозагрузки `autoloadFunc()`, которую
в дальнейшем будем именовать автозагрузчиком *карты классов* (class map autoloader).

Автозагрузчик карты классов использует карту для определения соответствия между именем
класса и абсолютным путем к PHP-файлу, содержащему этот класс. Карта классов - это всего лишь
обычный PHP-массив, содержащий ключи и значения. Чтобы определить путь к файлу по имени класса,
автозагрузчику просто нужно взять значение из массива карты классов. Очевидно, что автозагрузчик
работает очень быстро. Однако, его минус в том, что вам необходимо поддерживать карту классов и
обновлять ее каждый раз при добавлении в программу нового класса.

### Стандарт PSR-0

Так как каждый поставщик библиотек использует свои собственные правила наименования и организацию файлов,
вам придется регистрировать свою функцию автозагрузки для каждой зависимой библиотеки, что, конечно,
может надоедать (и вообще, это ненужный труд). Чтобы решить эту проблему, были введены стандарты PSR-0 и PSR-4.

I> PSR расшифровывается PHP Standards Recommendation (рекомендации стандартов PHP).

[Стандарт PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md)
определяет рекомендованную структуру кода, которую приложение или библиотека должны соблюдать,
чтобы обеспечить совместимость механизмов автозагрузки.

* Пространства имен класса должны быть организованы следующим образом: 

  `\<Имя поставщика>\(<Пространство имен>)*\<Имя класса>`
  
* Пространства имен могут иметь любое желаемое количество уровней вложенности,
  но *имя поставщика* должно быть пространством имен верхнего уровня.

* Пространства имен должны иметь соответствие один к одному со структурой каталогов. Каждый разделитель пространств имен (`\`)
  конвертируется в константу `DIRECTORY_SEPARATOR`, отличную для разных ОС.

* К имени класса добавляется суффикс расширения *.php* при загрузке файла из файловой системы.

Например, для класса `Zend\Mvc\Application`, 
у вас будет следующая структура каталогов:

{line-numbers=off,lang="text"}
~~~
/path/to/zend/lib
  /Zend
    /Mvc
       Application.php
~~~

Для соответствующего стандарту PSR-0 кода, мы можем написать и зарегистрировать автозагрузчик,
который будем именовать "стандартным" автозагрузчиком:

{line-numbers=off,lang="php"}
~~~
<?php

// "Стандартная" функция автозагрузки.
function standardAutoloadFunc($className) 
{
  // Заменяем специальные символы в имени класса.
  $className = str_replace('\\', '/', $className);
  // Форматируем строку пути к файлу.
  $fileName = "/path/to/zend/lib/" . $className . ".php";
  // Проверяем, существует ли файл и возможно ли его прочитать.
  if (is_readable($fileName)) {
    // Подключаем файл.
    require $fileName;
  } 
}

// Регистрируем функцию автозагрузки.
spl_autoload_register("standardAutoloadFunc");
~~~

Стандартный автозагрузчик работает следующим образом:
Предполагая, что пространство имен класса имеет соответствие один к одному со структурой каталогов,
функция вычисляет путь к PHP-файлу, преобразовывая обратные слеши (разделители пространств имен) в
прямые (разделители пути) и соединяя полученный путь с абсолютным путем к каталогу, где расположена
библиотека. Затем функция проверяет, существует ли уже такой PHP-файл, и, если он существует, включает
его с помощью оператора `require`.

Очевидно, что стандартный автозагрузчик работает медленнее, чем автозагрузчик карты классов.
Однако, его преимущество в том, что вам не нужно поддерживать карту классов, что очень удобно
при написании нового кода и добавлении новых классов к вашему приложению.

I> Zend Framework 3 работает в соответствии со стандартом PSR-4, что делает возможным 
I> автозагрузку всех его компонентов. Он также совместим с другими библиотеками, следующими
I> PSR-0, такими как Doctrine и Symfony.

### Стандарт PSR-4

[Стандарт PSR-4](http://www.php-fig.org/psr/psr-4/) - это расширение PSR-0. Главным нововведением является возможность 
определения соответствия "базового каталога" и последовательности одного или нескольких пространств и подпространств имен. 
Например, если у вас есть полностью определенное имя класса `\Zend\Mvc\Application` и вы определяете соответствие
между `\Zend\Mvc\` и каталогом "/path/to/zend/lib/", вы можете организовать файлы следующим образом:

```
/path/to/zend/lib/
    Application.php
```
 
I> Преимущество PSR-4 в том, что вам не нужно размещать ваш код в несколько вложенных каталогов,
как в PSR-0. 

### Автозагрузчик, предоставляемый Composer'ом
		
Zend Framework 3 использует реализацию механизмов автозагрузки, предоставляемую Composer'ом. При установке пакетов
Composer автоматически создается файл *APP_DIR/vendor/autoload.php*,
использующий функцию `spl_autoload_register()`, чтобы зарегистрировать автозагрузчик. Таким образом, все PHP-классы,
находящиеся в каталоге `APP_DIR/vendor` , корректно загружаются автоматически.

Для автозагрузки PHP-классов, расположенных в ваших собственных модулях (например, в модуле `Application`), вам нужно будет
указать ключ `autoload` в файле `composer.json`:

{line-numbers=off,lang="json",title="Autoload key of composer.json file"}
~~~
"autoload": {
    "psr-4": {
        "Application\\": "module/Application/src/"
    }
},
~~~

Затем все, что нужно будет сделать, это включить этот файл во входном скрипте `index.php` вашего веб-сайта:

{line-numbers=off,lang="php"}
```
// Автозагрузка Composer'a
include __DIR__ . '/../vendor/autoload.php';
```

### PSR-4 и структура исходных каталогов

В Zend Skeleton Application вы можете наблюдать стандарт PSR-4 на практике. 
Для стандартного модуля вашего сайта, модуля `Application`, PHP-классы, 
зарегистрированные стандартным автозагрузчиком, хранятся в каталоге `APP_DIR/module/Application/src` 
("src" - сокращение от "source" - "источник"). 

I> Мы будем называть каталог `src` исходным каталогом модуля.

Для примера рассмотрим файл `IndexController.php` модуля `Application` (рисунок 3.2). 

![Рисунок 3.2. Структура каталогов скелетного приложения соответствует стандарту PSR-4](../en/images/operation/psr0_and_dir_structure.png)

Как видите, он содержит класс `IndexController` [^контроллер], принадлежащий пространству имен `Application\Controller`. 
Чтобы соблюдать стандарт PSR-4 и использовать стандартный автозагрузчик с этим классом, 
нужно поместить его в директорию `Controller` в исходном каталоге модуля. 

[^контроллер]: Класс `IndexController` - это стандартный контроллер для скелетного сайта. 
               Мы будем говорить о контроллерах в главе [Модель-представление-контроллер](#mvc).

## HTTP-запросы и ответы

Когда пользователь сайта открывает веб-страницу в окне браузера, браузер генерирует запрос
и отсылает его через протокол HTTP веб-серверу. Сервер в свою очередь перенаправляет этот запрос
вашему приложению.

I> [HTTP](https://ru.wikipedia.org/wiki/HTTP) (расшифровывается как Hyper Text 
I> Transfer Protocol - "протокол передачи гипертекста") -- это протокол для передачи данных
I> в виде гипертекстовых документов (веб-страниц). HTTP основан на технологии "клиент-сервер":
I> клиент инициирует соединение и отсылает запрос веб-серверу, сервер ждет 
I> установки соединения, выполняет необходимые действия и посылает обратно ответ. 

Таким образом, главной целью, лежащей в основе любого веб-приложения, является обработка
HTTP-запроса и создание HTTP-ответа, обычно содержащего HTML-код запрашиваемый веб-страницы.
Ответ посылается сервером браузеру клиента, и браузер отображает веб-страницу на экране монитора.

Ниже представлен типичный HTTP-запрос:

{line-numbers=on,lang="text",title="An HTTP request example"}
~~~
GET http://www.w3schools.com/ HTTP/1.1
Host: www.w3schools.com
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) 
Accept-Encoding: gzip,deflate,sdch
Accept-Language: en-US;q=0.8,en;q=0.6
Cookie: __gads=ID=42213729da4df8df:T=1368250765:S=ALNI_MaOAFe3U1T9Syh; 
(empty line)
(message body goes here)
~~~

Этот HTTP-запрос состоит из трех частей:

* Начальная (первая) строка указывает метод запроса (т.е., GET или POST), строку URL 
  и версию протокола HTTP.
* Необязательные заголовки (строки 2-8) характеризуют сообщение, параметры передачи и предоставляют другую метаинформацию. 
  В этом примере каждая строка представляет из себя заголовок в виде *имя:значение*.
* Необязательное тело сообщения, содержащее его данные. Отделено от заголовков пустой строкой.
  
В запросе могут отсутствовать заголовки и тело сообщения, но он всегда содержит
начальную строку, потому что она указывает на его тип и URL.

Ответ сервера на этот запрос представлен ниже:

{line-numbers=on,lang="text",title="An HTTP response example"}
~~~
HTTP/1.1 200 OK
Cache-Control: private
Content-Type: text/html
Content-Encoding: gzip
Vary: Accept-Encoding
Server: Microsoft-IIS/7.5
Set-Cookie: ASPSESSIONIDQQRBACTR=FOCCINICEFAMEKODNKIBFOJP; path=/
X-Powered-By: ASP.NET
Date: Sun, 04 Aug 2013 13:33:59 GMT
Content-Length: 8434
(empty line)
(page content follows)
~~~

Как видите, HTTP-ответ имеет почти такой же вид, как и запрос:

* Начальная (первая строка) представляет собой версию протокола HTTP 
  и код статуса ответа (200 OK).

* Необязательные заголовки (строки 2-10) предоставляют различную метаинформацию об ответе.

* Необязательное тело сообщения, следующее за заголовками, должно быть отделено от них пустой строкой.
  оно, как правило, содержит HTML-код запрашиваемой веб-страницы

## Входной скрипт сайта

Когда веб-сервер Apache получает HTTP-запрос от браузера, он запускает
файл *APP_DIR/public/index.php*, также называемый *входной скрипт*.

I> Входной скрипт - это единственный PHP-файл, доступный для внешнего мира. Сервер
I> отравляет ему все HTTP-запросы (помните файл *.htaccess*?). Наличие такого  
I> скрипта делает сайт более безопасным (по сравнению с ситуацией, когда 
I> вы позволяете всем иметь доступ к файлам вашего приложения). 

Хотя файл *index.php* является очень важным, он на удивление невелик (см. ниже):

{line-numbers=on,lang=php}
~~~
<?php

use Zend\Mvc\Application;
use Zend\Stdlib\ArrayUtils;

/**
 * Это облегчает нам работу с путями. Все пути теперь - относительно корня приложения.
 */
chdir(dirname(__DIR__));

// Отклонить запросы статического файла
if (php_sapi_name() === 'cli-server') {
    $path = realpath(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH));
    if (__FILE__ !== $path && is_file($path)) {
        return false;
    }
    unset($path);
}

// Автозагрузка Composer
include __DIR__ . '/../vendor/autoload.php';

if (! class_exists(Application::class)) {
    throw new RuntimeException(
        "Unable to load application.\n"
        . "- Type `composer install` if you are developing locally.\n"
        . "- Type `vagrant ssh -c 'composer install'` if you are using Vagrant.\n"
        . "- Type `docker-compose run zf composer install` if you are using Docker.\n"
    );
}

// Извлечение конфигурации
$appConfig = require __DIR__ . '/../config/application.config.php';
if (file_exists(__DIR__ . '/../config/development.config.php')) {
    $appConfig = ArrayUtils::merge($appConfig, require __DIR__ . '/../config/development.config.php');
}

// Запуск приложения!
Application::init($appConfig)->run();
~~~

В нем, главным образом, делаются три вещи.

Во-первых, в строке 10, действующий в данный момент каталог меняется на `APP_DIR`.
Это упрощает определение относительных путей файлов вашего приложения.
   
Во-вторых, в строке 22 инициируется класс автозагрузки. Это позволяет легко загружать любой класс,
находящийся либо в библиотеке Zend Framework, либо в вашем приложении, без необходимости использования
оператора `require_once`.

И в-третьих, в строке 40 создается экземпляр класса `Zend\Mvc\Application`.
Приложение инициализируется с настройками из файла конфигурации *application.config.php*
и запускается.

## События и жизненный цикл приложения

Как вы поняли из предыдущего раздела, с каждым HTTP-запросом создается объект `Zend\Mvc\Application`.
"Жизненный цикл" приложения состоит из нескольких этапов.

I> Zend Framework 3 использует понятие *событие*. Класс может *вызвать* событие,
I> и другие классы могут его *обработать*. Технически вызов события - это просто вызов 
I> функции обратного вызова ("callback") другого класса. Управление событиями реализовано  
I> внутри компонента `Zend\EventManager`.

Каждый этап жизненного цикла приложения инициируется приложением путем вызова события. Другие классы
(принадлежащие либо Zend Framework, либо вашему приложению) могут обработать события и отреагировать
соответствующим образом.
 
Ниже представлены четыре основных этапа жизненного цикла приложения:

**Начальная загрузка (Bootstrap)**. При вызове этого события, модуль может зарегистрировать себя
как обработчика будущих событий приложения в своей функции обратного вызова `onBootstrap().` 

**Маршрутизация (Route)**. При вызове этого события, запрашиваемый URL анализируется с помощью класса *маршрутизации* (как правило, 
класса `Zend\Router\Http\TreeRouteStack`). Если удается найти полное совпадение между URL и маршрутом,
запрос передается классу *контроллера* этого маршрута.

**Отправка (Dispatch)**. Класс контроллера "отправляет" запрос, используя соответствующий метод действия и создает данные, 
которые могут быть отображены на веб-странице. 

**Рендеринг (Render)**. В этом событии данные, созданные методом действия контроллера, передаются для визуализации классу 
`Zend\View\Renderer\PhpRenderer`. Визуализатор использует файл
*шаблона представления* для создания HTML-страницы.

Последовательность событий представлена на рисунке 3.3:

![Рисунок 3.3. Последовательность событий в течение жизненного цикла приложения](../en/images/operation/app_life_cycle.png)

T> Практические примеры обработки и реакции на событие можно найти в главе [Создание нового модуля](#modules)


## Конфигурация приложения

Большинство компонентов Zend Framework, используемых на вашем сайте, требуют 
конфигурации (тонкой настройки). Например, в файле конфигурации 
вы можете установить настройки подключения для базы данных, определить, какие
модули присутствуют в вашем приложении и добавить некоторые
пользовательские параметры.

Вы можете определить параметры конфигурации на двух уровнях: либо на уровне приложения,
либо на уровне модуля. На уровне приложения обычно определяются параметры, которые контролируют
всю программу и являются общими для всех модулей приложения. На уровне модуля определяются параметры,
которые затрагивают только этот модуль.

I> Некоторые PHP-фреймворки предпочитают принцип *соглашения превыше конфигурации* (Сonvention over Сonfiguration), при
I> котором большинство параметров жестко закодированы и не требуют конфигурации.
I> Это ускоряет разработку приложения, но делает его менее настраиваемым.
I> В Zend Framework 3 используется принцип *конфигурация превыше соглашений*,
I> то есть, вы можете настроить каждый аспект вашего приложения, но вам придется
I> потратить немого времени прежде, чем вы научитесь это делать.

### Файлы настройки на уровне приложения

Подкаталог *APP_DIR/config* содержит файлы конфигурации, действующие для всего приложения. Рассмотрим
этот подкаталог более детально (рисунок 3.4).

![Рисунок 3.4. Конфигурационные файлы](../en/images/operation/config.png)

Файл *APP_DIR/config/application.config.php* - это основной файл конфигурации.
Он используется приложением при запуске для определения, какие модули приложения должны быть
загружены и какие сервисы созданы по умолчанию.
        
Ниже представлен начальный фрагмент файла *application.config.file*. 
Как видите, файл конфигурации является обычным вложенным ассоциативным 
массивом, и каждый компонент этого массива может иметь особый ключ.
Вы можете оставить комментарии к этим ключам, чтобы другим было проще понять, что
означает каждый из них. 

T> Принято давать ключам имена в нижнем регистре, и, если имя ключа состоит из 
T> нескольких слов, их следует разделять нижним подчеркиванием ('_').

{line-numbers=on,lang=php, title="Content of application.config.php file"}
~~~
return [
    // Извлекаем список модулей, используемых в этом приложении.
    'modules' => require __DIR__ . '/modules.config.php',

    // Существует несколько вариантов для обработчиков, прикрепленных к ModuleManager
    'module_listener_options' => [
        // Это должен быть массив путей, в которых находятся модули.
        // Если есть строка с ключом, обработчик посчитает ее пространством имен модуля,
        // значение этого ключа - путем к классу Module этого модуля.
        'module_paths' => [
            './module',
            './vendor',
        ],

        // Массив путей, для которых используется функция glob (поиск пути к файлам) после
        // загрузки модуля. Таким образом, настройки, предоставляемые модулем, переопределяются.
        // Пути могут иметь флаг GLOB_BRACE.
        'config_glob_paths' => [
            realpath(__DIR__) . '/autoload/{{,*.}global,{,*.}local}.php',
        ],

        // Включать или нет кэш конфигурации.
        // Если он включен, файлы конфигурации после слияния будут кэшированы
        // и использованы при последующих запросах.
        'config_cache_enabled' => true,

        // Ключ, используемый для создания имени файла кэша конфигурации.
        'config_cache_key' => 'application.config.cache',

        // Включать или нет кэш карты классов модуля.
        // Если он включен, создается кэш карты классов модуля, который будет использоваться
        // при последующих запросах для сокращения времени автозагрузки.
        'module_map_cache_enabled' => true,

        // Ключ, используемый для создания имени файла кэша карты классов.
        'module_map_cache_key' => 'application.module.cache',

        // Путь, в который кэшируется конфигурация после слияния.
        'cache_dir' => 'data/cache/',

        // Включать или нет проверку зависимостей модулей (включена по умолчанию).
        // Это предотвращает использование модулей, который зависит от других, не
        // загруженных модулей.
        // 'check_dependencies' => true,
    ],

    // Используется для создания собственного менеджера сервисов. Может содержать один или несколько дочерних массивов.
    //'service_listener_options' => [
    //     [
    //         'service_manager' => $stringServiceManagerName,
    //         'config_key'      => $stringConfigKey,
    //         'interface'       => $stringOptionalInterface,
    //         'method'          => $stringRequiredMethodName,
    //     ],
    // ],

   // Начальная конфигурация, которая подается ServiceManager'у.
   // Должна быть совместима с Zend\ServiceManager\Config.
   // 'service_manager' => [],
];
~~~ 

В строке 3 у нас есть ключ *modules*, определяющий, какие модули будут загружены при запуске. Как вы видите,
имена модулей хранятся внутри другого файла конфигурации `modules.config.php`, который содержит список
всех модулей вашего сайта. 

В строке 11 находится ключ `module_paths`, который сообщает ZF3 о
каталогах, в которых нужно искать файлы источников, принадлежащие модулям. Модули приложения,
разрабатываемые вами, находятся в каталоге *APP_DIR/module*, а сторонние модули -  
в каталоге *APP_DIR/vendor*.

Наконец, строка 19 содержит ключ `config_glob_paths`, который сообщает ZF3, где искать
дополнительные файлы конфигурации. Как видите, файлы из каталога *APP_DIR/config/autoload*
с суффиксами *global.php* или *local.php* загружаются автоматически.

Итак, как правило, вы используете главный файл настроек *application.config.php* для хранения информации 
о том, какие модули должны быть загружены, а также их местоположение и способ загрузки (здесь, например, вы
можете управлять настройками кэширования). В этом файле вы помимо этого можете настроить менеджер сервисов.
Не рекомендуется добавлять дополнительные ключи в этот файл. Для этой цели лучше использовать файл `autoload/global.php`.

Давайте также заглянем внутрь файла `modules.config.php`. На данный момент у вас
установлены следующие модули:

{line-numbers=off,lang=php, title="Content of modules.config.php file"}
~~~
return [
    'Zend\Session',
    'Zend\Mvc\Plugin\Prg',
    'Zend\Mvc\Plugin\Identity',
    'Zend\Mvc\Plugin\FlashMessenger',
    'Zend\Mvc\Plugin\FilePrg',
    'Zend\Form',
    'Zend\Router',
    'Zend\Validator',
    'Application',
];
~~~

Модуль `Application` - это модуль, содержащий файлы вашего приложения. Все остальные перечисленные модули - это
компоненты Zend Framework 3.

I> В ZF3 был представлен специальный плагин Composer'a, называемый *установщиком компонентов*. Если помните, в
главе [Zend Skeleton Application](#skeleton), мы отвечали на несколько вопросов об установщике, определяя,
какие компоненты устанавливать. И установщик вставил имена этих модулей здесь, в файле `modules.config.php`

### Дополнительные файлы конфигурации на уровне приложения

"Дополнительные" файлы конфигурации, *APP_DIR/config/autoload/global.php* и *APP_DIR/config/autoload/local.php*
определяют соответственно не зависимые и зависимые от окружения настройки, применимые для всего приложения.
Эти файлы конфигурации загружаются автоматически и рекурсивно сливаются с файлами конфигурации, предоставляемыми
модулями, поэтому их каталог называется *autoload*.

Имея несколько файлов конфигурации в каталоге *APP_DIR/config/autoload*, вы, возможно, запутаетесь
с тем, какие параметры в какой файл поместить. Вот несколько советов:
  
* Используйте файл *autoload/global.php* для хранения параметров, которые не зависят от
  окружения конкретной машины: например, тех, что переопределяют параметры по умолчанию некоторого модуля.  
  Не храните здесь чувствительную информацию (такую как учетные данные базы данных), для этой цели
  лучше использовать *autoload/local.php*.
            
* Используйте файл *autoload/local.php* для хранения параметров, специфичных для
  конкретного окружения: например, учетные данные базы данных.
  У каждого разработчика обычно есть локальная база данных для разработки и тестирования веб-сайта.
  Таким образом, разработчик будет изменять файл учетные данные базы данных и вводить туда учетные данные
  своей БД. При установке сайта на "боевой" сервер (production server) файл `local.php` вновь изменяется,
  и в него записываются учетные данные "реальной" базы.

I> Так как файл *autoload/local.php* содержит зависимые от окружения параметры, 
I> в системе контроля версий вы храните его "шаблон рапсределения" *local.php.dist*.
I> Каждый разработчик вашей команды затем переименовывает файл *local.php.dist* в *local.php* и
I> вводит свои собственные параметры. Файл *local.php* не следует хранить под системой
I> контроля версий, потому что он может хранить чувствительную информацию вроде учетных данных 
I> БД (логины и пароли), и вы, скорее всего, не захотите, чтобы их увидели другие.     

### Файл конфигурации разработки на уровне приложения

С файлом конфигурации разработки (`APP_DIR/config/development.config.php`) вы столкнетесь при включении
*режима разработки*. Если помните, мы включали этот режим ранее в главе [Zend Skeleton Application](#skeleton).

I> Режим разработки включается следующей командой:
I>
I> `php composer.phar development-enable`

Файл `development.config.php` сливается с главным файлом `application.config.php`. Это позволяет вам
переопределить некоторые параметры. Например, вы можете:

  * отключить кэширование конфигурации. При разработке сайта вы часто изменяете ваши файлы настроек, поэтому
    кэширование конфигурации может иметь нежелательные последствия, например, неспособность сразу увидеть результат ваших изменений.
  * загрузить дополнительные модули. Например, вы можете загрузить модуль [ZendDeveloperTools](https://github.com/zendframework/ZendDeveloperTools) только в режиме разработки.   

Если вы выключите режим разработки, файл `development.config.php` будет удален. Поэтому хранить этот
файл под системой контроля версий не стоит. Вместо этого храните таким образом его вариант *распределения*, `development.config.php.dist`.
 
### Файлы конфигурации на уровне модуля

Как видно из рисунка 3.4, у модуля *Application* есть файл *module.config.php*, в котором
хранятся параметры, специфичные для этого модуля. Взглянем на 
файл `module.config.php` модуля `Application`:

{line-numbers=off,lang=php, title="module.config.php file"}
~~~
<?php
namespace Application;

use Zend\Router\Http\Literal;
use Zend\Router\Http\Segment;
use Zend\ServiceManager\Factory\InvokableFactory;

return [
    'router' => [
        'routes' => [
            'home' => [
                'type' => Literal::class,
                'options' => [
                    'route'    => '/',
                    'defaults' => [
                        'controller' => Controller\IndexController::class,
                        'action'     => 'index',
                    ],
                ],
            ],
            'application' => [
                'type'    => Segment::class,
                'options' => [
                    'route'    => '/application[/:action]',
                    'defaults' => [
                        'controller'    => Controller\IndexController::class,
                        'action'        => 'index',
                    ],
                ],
            ],
        ],
    ],
    'controllers' => [
        'factories' => [
            Controller\IndexController::class => InvokableFactory::class,
        ],
    ],
    'view_manager' => [
        'display_not_found_reason' => true,
        'display_exceptions'       => true,
        'doctype'                  => 'HTML5',
        'not_found_template'       => 'error/404',
        'exception_template'       => 'error/index',
        'template_map' => [
            'layout/layout'           => __DIR__ . '/../view/layout/layout.phtml',
            'application/index/index' => __DIR__ . '/../view/application/index/index.phtml',
            'error/404'               => __DIR__ . '/../view/error/404.phtml',
            'error/index'             => __DIR__ . '/../view/error/index.phtml',
        ],
        'template_path_stack' => [
            __DIR__ . '/../view',
        ],
    ],
];
~~~

В этом файле вы регистрируете контроллеры модуля, помещаете в него информацию о правилах маршрутизации
для определения соответствия между URL и вашими контроллерами, регистрируете плагины контроллеров, а также 
регистрируете шаблоны представления и помощники представления (мы узнаем больше об этих терминах в этой и следующих главах).

### Объединение файлов конфигурации

При создании приложения, файлы конфигурации, предоставляемые модулем, и дополнительные файлы конфигурации из каталога
*APP_DIR/config/autoload* соединяются в один большой вложенный массив, так что каждый
параметр конфигурации становится доступным для каждой детали вашего сайта. 
Таким образом, у вас есть возможность переопределить любые параметры, заданные модулями.        

I> Возможно, вы видели "объединенный" файл конфигурации при установке PHP, где есть главный
I> файл *php.ini* и несколько дополнительных файлов конфигурации, включенных в него.
I> Такое разделение делает настройку вашего приложения многогранной и гибкой, 
I> потому что вам не нужно помещать все ваши параметры в один файл и изменять его
I> каждый раз, когда необходимо внести какие-то изменения.

Файлы конфигурации загружаются в следующем порядке:

* Главный файл *application.config.php* загружается первым. Он используется для инициализации
  менеджера сервисов и загрузки модулей приложения. Данные, загруженные из этого файла, хранятся
  отдельно и не сливаются с другими файлами конфигурации.

* Затем загружаются и объединяются файлы конфигурации для каждого модуля приложения.
  Модули загружаются в том же порядке, в котором они перечислены в файле *application.config.php*.
  Если два модуля хранят параметры в ключах с одинаковыми названиями (либо намеренно, либо по ошибке),
  эти параметры могут быть перезаписаны.
  
* Затем загружаются и объединяются в один массив дополнительный файлы конфигурации из каталога *APP_DIR/config/autoload*.
  Этот массив затем сливается с массивом конфигурации модуля, созданным на предыдущем этапе.  
  Конфигурация на уровне приложения имеет более высокий приоритет, чем конфигурация модуля, поэтому здесь
  вы при желании можете переопределить ключи модулей.
  
## Точка входа модуля

Каждый модуль веб-приложения имеет файл *Module.php*, который является своеобразной 
*точкой входа* для этого модуля. Этот файл содержит класс `Module`. Ниже
представлено содержимое класса `Module` скелетного приложения:

{line-numbers=on, lang=php, title="Contents of Module.php file"}
~~~
<?php 
namespace Application;

class Module
{
    const VERSION = '3.0.0dev';

    public function getConfig()
    {
        return include __DIR__ . '/../config/module.config.php';
    }
}
~~~

Класс `Module` принадлежит пространству имен модуля (в случае с главным модулем, он
принадлежит пространству имен `Application`).

Метод `getConfig()` (строки 16-19) сообщает Zend Framework, где 
расположен файл *module.config.php*.

I> Вы также можете зарегистрировать здесь *обработчики событий*, мы рассмотрим, как это
I> сделать в главе [Создание нового модуля](#modules)
  
## Менеджер сервисов

Веб-приложение можно представить как набор *сервисов*. Например,
у вас может быть сервис аутентификации, ответственный за вход пользователей на сайт,
менеджер сущностей, ответственный за доступ к базе данных, менеджер событий, ответственный
за вызов событий и их обработку, и т.д.

В Zend Framework класс `ServiceManager` - это централизованный репозиторий для всех 
сервисов приложения. Менеджер сервисов  реализован в компоненте
`Zend\ServiceManager` в качестве класса `ServiceManager`.

Менеджер сервисов создается при запуске приложения (внутри статического метода `init()`
класса `Zend\Mvc\Application`).
Стандартные сервисы, доступные через менеджер сервисов, представлены в таблице 3.1.
Эта таблица неполная, так как реальное число сервисов, зарегистрированных в менеджере
может быть намного больше.

{title="Table 3.1. Standard services"}
|----------------------|-----------------------------------------------------------------------|
| Имя сервиса          | Описание                                                              |
|----------------------|-----------------------------------------------------------------------|
| Application          | Позволяет излечь единственный экземпляр класса `Zend\Mvc\Application`.|
|----------------------|-----------------------------------------------------------------------|
| ApplicationConfig    | Массив конфигурации из файла *application.config.php* file.           |
|----------------------|-----------------------------------------------------------------------|
| Config               | Объединенный массив конфигурации из файлов *module.config.php*,       |
|                      | *autoload/global.php* и *autoload/local.php*.                         |
|----------------------|-----------------------------------------------------------------------|
| EventManager         | Позволяет излечь единственный экземпляр класса `Zend\Mvc\EventManager`. |
|                      | Менеджер событий позволяет вызывать события и прикреплять обработчики. |
|----------------------|-----------------------------------------------------------------------|
| ModuleManager        | Позволяет излечь единственный экземпляр класса `Zend\Mvc\ModuleManager`. |
|                      | Менеджер модулей отвечает за загрузку модулей приложения.             |
|----------------------|-----------------------------------------------------------------------|
| Request              | Единственный экземпляр класса `Zend\Http\Request`. Представляет собой HTTP-запрос, |
|                      | полученный от клиента.                                                |
|----------------------|-----------------------------------------------------------------------|
| Response             | Единственный экземпляр класса `Zend\Http\Response`. Представляет собой HTTP-ответ,  |
|                      | который будет отправлен клиенту.                                      |            
|----------------------|-----------------------------------------------------------------------|
| Router               | Единственный экземпляр класса `Zend\Router\Http\TreeRouteStack`. Осуществляет маршрутизацию URL. |
|----------------------|-----------------------------------------------------------------------|
| ServiceManager       | Собственно, сам менеджер сервисов.                                    |
|----------------------|-----------------------------------------------------------------------|
| ViewManager          | Единственный экземпляр класса `Zend\Mvc\View\Http\ViewManager`. Отвечает за |
|                      | подготовку слоя представления к визуализации страницы.                |
|----------------------|-----------------------------------------------------------------------|

Сервисом обычно является произвольный PHP-класс, но это не всегда так. Например, когда ZF3
загружает файлы конфигурации и объединяет данные во вложенные массивы, он сохраняет массивы
в менеджере сервисов как несколько сервисов (!): `ApplicationConfig` and `Config`. 
Первый - массив, загружаемый из файла конфигурации на уровне приложения *application.config.php*,
второй - объединенный массив из файлов конфигурации на уровне модулей и автоматически загруженных
файлов конфигурации на уровне приложения. Таким образом, в менеджере сервисов вы можете хранить
что хотите: PHP-класс, переменную или массив.

Из таблицы 3.1 видно, что в ZF3 все может считаться сервисом - даже сам менеджер сервисов.
Более того, класс `Application` также зарегистрирован, как сервис.  

I> Важная деталь о сервисах, на которую надо обратить внимание: они, как правило,
I> хранятся в единственном экземпляре (это называется шаблоном проектирования *одиночка* - *singleton*). Очевидно,
I> вам не нужен второй экземпляр класса `Application` или, скажем, менеджер событий (в этом случае
I> вам будут гарантированы кошмары). 

Менеджер сервисов определяет методы, необходимые для нахождения сервиса
и его извлечения из менеджера:

{line-numbers=off,lang=php}
~~~
// Извлекает экземпляр зарегистрированного сервиса.
public function get($name);

// Проверяет, зарегистрирован ли такой сервис.
public function has($name);
~~~

Вы можете проверить, зарегистрирован ли сервис, передав его имя методу `has()`
менеджера сервисов. Он возвращает `true`, если сервис зарегистрирован, или `false`,
если сервис с таким именем не зарегистрирован.

Вы можете извлечь сервис по его имени в любом месте вашего приложения с помощью
метода `get()` менеджера сервисов. Этот метод принимает один единственный параметр,
представляющий имя сервиса. Взглянем на следующий пример:

{line-numbers=off,lang=php}
~~~
<?php 

// Извлекает массив конфигурации приложения.
$appConfig = $serviceManager->get('ApplicationConfig');

// Использует его (например, извлекает список модулей).
$modules = $appConfig['modules'];
~~~		

### Имена сервисов

Разные сервисы могут использовать разные стили именования. Например, один и тот же
сервис конвертации валюты может быть зарегистрирован под разными именами: `CurrencyConverter`,  
`currency_converter` и так далее. Чтобы применить некоторые правила формирования имен, рекомендуется регистрировать 
сервис, используя его полностью определенное имя, следующим образом:

~~~
$serviceManager->setService(CurrencyConverter::class);
~~~

В примере выше мы используем ключевое слово `class`. Оно появилось в версии PHP 5.5 и используется 
для разрешения имен классов. Имя `CurrencyConverter::class` расширено до полностью определенного, 
как `\Application\Service\CurrencyConverter`.

### Регистрация сервиса

При написании веб-сайта, вам иногда придется регистрировать ваш собственный сервис в менеджере
сервисов. Чтобы это сделать, используйте метод `setService()`. Давайте создадим и зарегистрируем
класс сервиса конвертера валют, который будет использоваться, например, на странице корзины покупок
для конвертации EUR->USD.

{line-numbers=on,lang=php}
~~~
<?php 
// Определяем пространство имен, где находится наш сервис.
namespace Application\Service;

// Определяем класс сервиса конвертера.
class CurrencyConverter 
{
  // Конвертирование евро в доллары.
  public function convertEURtoUSD($amount) 
  {
    return $amount*1.25;
  }
	
  //...
}
~~~

В строках 6-15 мы определяем класс `CurrencyConverter` (для упрощения он будет иметь
только один метод - метод конвертации валют `convertEURtoUSD()`).

{line-numbers=off,lang=php}
~~~
// Создаем экземпляр класса.
$service = new CurrencyConverter();
// Сохраняем его в менеджере сервисов.
$serviceManager->setService(CurrencyConverter::class, $service);
~~~

В примере выше мы инстанцируем класс с помощью оператора `new` и регистрируем его с помощью
метода менеджера сервисов `setService()` (мы полагаем, что переменная `$serviceManager` - 
типа класса `Zend\ServiceManager\ServiceManager` и была объявлена где-то еще). 

Метод `setService()` принимает два параметра: строку с именем сервиса и экземпляр сервиса.
Имя сервиса должно быть уникальным среди имен всех возможных сервисов. Если вы попытаетесь
зарегистрировать имя сервиса, которое уже существует, метод выбросит исключение. Однако иногда
вы хотите переопределить сервис с таким же именем (чтобы заменить его новым). Для этого вы
можете использовать метод `setAllowOverride()` менеджера сервисов:

{line-numbers=of,lang=php}
~~~
<?php 
// Позволяет заменять сервисы 
$serviceManager->setAllowOverride(true);

// Сохраняет экземпляр в менеджер сервисов. Исключения не будет,
// даже если есть другой сервис с таким именем.
$serviceManager->setService(CurrencyConverter::class, $service);
~~~

В коде выше метод `setAllowOverride()` берет один булевый параметр, определяющий, разрешать ли
замену сервиса `CurrencyConverter`, если такое имя уже существует, или нет.

Как только сервис помещается в менеджер сервисов, вы можете извлечь его имя в любом месте
вашего приложения с помощью метода `get()`. Посмотрим на следующий пример:

{line-numbers=off,lang=php}
~~~
<?php 
// Извлекает менеджер конвертации валют.
$service = $serviceManager->get(CurrencyConverter::class);

// Использует его (конвертирует средства).
$convertedAmount = $service->convertEURtoUSD(50);
~~~		
		
### Регистрация вызываемых (invokable) классов		

Минус метода `setService()` в том, что необходимо создавать экземпляр сервиса до того,
как он на самом деле понадобится. Если вы не используете сервис вообще, инстанцирование
сервиса будет лишь тратой времени и памяти. Чтобы решить эту проблему, менеджер сервисов
предоставляет метод `setInvokableClass()`.

{line-numbers=off,lang=php}
~~~
<?php 
// Регистрация вызываемого класса
$serviceManager->setInvokableClass(CurrencyConverter::class);
~~~

В этом примере мы передаем менеджеру сервисов полностью определенное имя сервиса вместо того,
чтобы передавать его экземпляр. Таким образом, сервис будет инстанцирован менеджером только тогда, когда
кто-нибудь вызовет метод `get(CurrencyConverter::class)`. Это также называется ленивой загрузкой.

### Регистрация фабрик

Иногда инстанцирование сервиса может быть сложнее, чем просто создание экземпляра сервиса через
оператор `new`. Вам, возможно, придется передать некоторые параметры конструктору сервиса или вызвать
некоторые методы сервиса сразу после их создания. Эти сложные алгоритмы инстанцирования могут быть инкапсулированы
в фабрику. Фабрика - это PHP-класс, ответственный за создание новый объектов. Как правило, он 
реализует `FactoryInterface`:

{line-numbers=off,lang=php}
~~~
<?php
namespace Zend\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface FactoryInterface
{
    public function __invoke(ContainerInterface $container, 
                        $requestedName, array $options = null);
}
~~~

Как видно из определения `FactoryInterface`, фабричный класс должен предоставлять магический
метод `__invoke` , возвращающий экземпляр одного сервиса. Менеджер сервисов передается
методу `__invoke` как параметр `$container`; он может использоваться при создании сервиса
для доступа к другим сервисам (для внедрения *зависимостей*).

Для примера давайте напишем фабрику для нашего сервиса конвертации валют (см. код ниже).
Мы не будем использовать сложные алгоритмы создания сервиса `CurrencyConverter`, но для более
тяжелых сервисов, вам, возможно, они понадобятся.

{line-numbers=off,lang=php}
~~~
<?php 
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;

// Класс фабрики
class CurrencyConverterFactory implements FactoryInterface
{
  public function __invoke(ContainerInterface $container, 
                     $requestedName, array $options = null) 
  {
    // Создание экземпляра класса.
    $service = new CurrencyConverter();	
	
    return $service;
  }
}
~~~

Возможен еще более сложный случай фабрики - когда вам нужно определить,
какие сервисы должны быть зарегистрированы и какие не должны во время выполнения.
В этой ситуации вы можете использовать *абстрактную фабрику*. Класс абстрактной
фабрики должен определять интерфейс `AbstractFactoryInterface`:

{line-numbers=off,lang=php}
~~~
<?php 
namespace Zend\ServiceManager\Factory;

use Interop\Container\ContainerInterface;

interface AbstractFactoryInterface extends FactoryInterface
{
    public function canCreate(ContainerInterface $container, $requestedName);
}
~~~

Интерфейс `AbstractFactoryInterface` имеет два метода: `canCreate()`
и `__invoke()`. Первый нужен для проверки того, может ли фабрика создать
сервис с определенным именем. Второй позволяет, собственно, создать сервис.
Оба метода принимают два параметра: менеджер сервисов и имя сервиса.

По сравнению с обычным классом фабрики, разница состоит в том, что обычный класс может
создать только один сервис, в то время как абстрактный может динамически создать столько
сервисов, сколько необходимо.

### Регистрация псевдонима сервиса

Иногда вам понадобится создать *псевдоним* для сервиса. Псевдоним
похож на символьную ссылку: он ссылается на уже существующий сервис.
Для создания псевдонима используется метод менеджера сервисов `setAlias()`:

{line-numbers=off,lang=php}
~~~
<?php 
// Регистрируем псевдоним для сервиса CurrencyConverter
$serviceManager->setAlias('CurConv', CurrencyConverter::class);
~~~

После регистрации псевдонима вы можете извлечь сервис и по его имени, и по псевдониму,
используя метод `get()`.

### Конфигурация менеджера сервисов

Для автоматической регистрации сервиса в менеджере, как правило, используется
ключ `service_manager` файла конфигурации. Вы можете поместить этот ключ либо
в файл конфигурации на уровне приложения, либо файл конфигурации на уровне модуля.

W> Если вы поместили этот ключ в файл конфигурации на уровне модуля, помните
W> об опасности перезаписи имени во время слияния конфигураций.
W> Не регистрируйте одинаковые имена сервисов в разных модулях.

Ключ `service_manager` должен выглядеть так:

{line-numbers=on,lang=php}
~~~
<?php 
return [
  //...

  // Регистрация сервисов под этим ключом
  'service_manager' => [
    'services' => [
      // Регистрация экземпляров классов сервисов
      //...
    ],
    'invokables' => [
      // Регистрация вызываемых классов
      //...
    ],
    'factories' => [
      // Регистрация фабрик
      //...
    ],
    'abstract_factories' => [
      // Регистрация абстрактных фабрик
      //...
    ],
    'aliases' => [
      // Регистрация псевдонимов сервисов
      //...
    ],
  ],
  
  //...
];
~~~

Как видите в примере выше, ключ `service_manager` может содержать несколько
подключей для регистрации сервисов по-разному:

* подключ `services` (строка 7) позволяет зарегистрировать экземпляры классов;
* подключ `invokables` (строка 11) позволяет зарегистрировать полное имя класса сервиса;
  сервис будет инстанцирован с использованием ленивой загрузки;
* подключ `factories` (строка 15) позволяет зарегистрировать фабрику, которая сможет
  создавать экземпляры одного сервиса;
* `abstract_factories` (строка 19) может быть использован для регистрации абстрактных фабрик,
  которые могут регистрировать несколько сервисов по имени;
* подключ `aliases` (строка 23) предоставляет возможность зарегистрировать псевдоним для сервиса.

## Менеджеры плагинов

Теперь, когда вы понимаете, что такое менеджер сервисов, понятие
*менеджеров плагинов* не должно вызывать трудностей. *Менеджер плагинов* - почти то же самое, что
и менеджер сервисов, но он может инстанцировать сервисы только одного типа. Какого - 
жестко закодировано в классе менеджера плагинов.

Зачем это может понадобиться? На самом деле, плагины менеджеров широко используются в ZF3. Существуют
отдельные менеджеры плагинов для:

  * контроллеров (класс `Zend\Mvc\Controller\ControllerManager`)
  * плагинов контроллеров (класс `Zend\Mvc\Controller\PluginManager`)
  * помощников представлений (класс `Zend\View\HelperPluginManager`)
  * элементов форм (класс `Zend\Form\FormElementManager\FormElementManagerV3Polyfill`) 
  * фильтров (класс `Zend\Filter\FilterPluginManager`)
  * валидаторов (класс `Zend\Validator\ValidatorPluginManager`)
  * и, возможно, чего-то другого
  
Так как любой менеджер плагинов наследуется от базового класса `Zend\ServiceManager\ServiceManager`,
все менеджеры плагинов могут иметь схожую конфигурацию. Например, контроллеры регистрируются под
ключом `controllers` в файле *module.config.php*, и у этого ключа могут быть те же подключи:
*services*, *invokables*, *factories*, *abstract_factories*, и *aliases*. Эту же структуру
имеет ключ *view_helpers*, используемый для регистрации помощников представлений, и ключ *controller_plugins*,
используемый для регистрации плагинов контроллера, и так далее.

## Выводы

В этой главе мы ознакомились с теорией основ работы сайта на базе ZF3.

ZF3 использует пространства имен PHP и автозагрузку классов, упрощая тем самым
разработку приложений, которые используют сторонние компоненты. Пространства имен позволяют
разрешать конфликты имен между компонентами кода и позволяют делать длинные имена короче.

Автозагрузка классов делает возможным использование любого PHP-класса в любой библиотеке, установленной с
Composer, без использования оператора `require_once`. Composer также предоставляет автозагрузчик PSR-4
для классов, расположенных в модулях вашего веб-приложения.

Большинство компонентов Zend Framework 3 требуют конфигурации. Вы можете определить параметры конфигурации либо
на уровне приложения, либо на уровне модулей. 

Главная цель любого веб-приложения - обработка HTTP-запроса и создание HTTP-ответа, содержащего,
как правило, HTML-код запрашиваемой веб-страницы. Когда веб-сервер Apache получает HTTP-запрос от
браузера клиента, он запускает файл *index.php*, который также называется скриптом входа на сайт.
Для каждого HTTP-запроса создается объект `Zend\Mvc\Application`, чей "жизненный цикл" состоит из нескольких
этапов (или событий).

Бизнес-логика веб-приложения тоже может считаться набором сервисов. В Zend Framework 3 менеджер сервисов -
это централизованный репозиторий для всех сервисов приложения. Сервис - это, как правило, PHP-класс, но,
в целом, это при необходимости может быть и переменная или массив.
