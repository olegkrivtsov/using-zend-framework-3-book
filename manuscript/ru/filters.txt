# Преобразование входных данных с помощью фильтров {#filters}

В этой главе мы рассмотрим стандартные фильтры, которые можно использовать для веб-форм.
Фильтр - это класс, который принимает входные данные, обрабатывает их и создает выходные данные.
Кроме этого, мы покажем, как написать свой собственный фильтр.

I> В целом, фильтры можно использовать даже *вне* форм для обработки произвольных данных.
I> Например, вы можете использовать фильтры в действии контроллера для преобразования данных,
I> переданных в качестве переменных GET и/или POST, в определенный формат.

Компоненты ZF3, рассматриваемые в этой главе:

|--------------------------------|---------------------------------------------------------------|
| *Компонент*                    | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `Zend\Filter`                  | Содержит различные классы фильтров.                           |
|--------------------------------|---------------------------------------------------------------|
| `Zend\InputFilter`             | Реализует контейнер для фильтров/валидаторов.                 |
|--------------------------------|---------------------------------------------------------------|

## О фильтрах

Фильтры предназначены для приема входных данных, их обработки, а затем создания выходных данных.
Zend Framework 3 предоставляет множество стандартных фильтров, которые можно использовать для создания
правил фильтрации ваших форм (или, если хотите, для фильтрации произвольных данных вне форм).

### FilterInterface

Технически, *фильтр* - это PHP-класс, реализующий интерфейс `FilterInterface` (он принадлежит
пространству имен `Zend\Filter`). Определение интерфейса представлено ниже:

{line-numbers=on, lang=php}
~~~
<?php
namespace Zend\Filter;

interface FilterInterface
{
    // Возвращает результат фильтрации $value.
    public function filter($value);
}
~~~

Как видите, интерфейс `FilterInterface` имеет один единственный метод `filter()` (строка 7), который
принимает один параметр `$value`. Этот метод преобразовывает входные данные и затем возвращает получившееся
(отфильтрованное) значение.

T> В отдельных случаях класс фильтра, реализующий интерфейс `FilterInterface`, может иметь и другие методы.
T> Например, у большого количества классов есть методы для конфигурации фильтра (задания опций фильтрации).

## Обзор стандартных фильтров

Стандартные фильтры, реализующие интерфейс `FilterInterface`, принадлежат компоненту `Zend\Filter` [^стандартные_фильтры].
Диаграмма наследования классов фильтров показана на рисунке 8.1. Как видите из рисунка, базовый класс для большинства
стандартных фильтров - класс `AbstractFilter`, реализующий интерфейс `FilterInterface` [^наследование_фильтров]

![Figure 8.1. Наследование классов фильтров](../en/images/filters/filter_inheritance.png)

[^стандартные_фильтры]: В этом разделе мы считаем стандартными только те фильтры, которые принадлежат пространству имен `Zend\Filter`,
              однако существуют и другие фильтры, которые можно считать стандартными. Например, пространство имен `Zend\Filter\File`
			  содержит несколько фильтров, применимых для обработки загрузок файлов (эти фильтры будут рассмотрены в следующих разделах).
			  Кроме этого, компонент `Zend\I18n` определяет несколько классов фильтров, которые осведомлены о локали (региональных настройках) пользователя).
			  

[^наследование_фильтров]: Из рисунка выше также можно заметить, что существует еще несколько базовых фильтров: `AbstractUnicode` - базовый класс
              для фильтров `StringToUpper` и `StringToLower`, так как он предоставляет общий для обоих набор функций для преобразования строк.
			  Фильтр `Decompress` наследуется от фильтра `Compress`, так как эти фильтры, на самом деле, очень похожи. Аналогично, фильтр `Decrypt` 
			  наследуется от фильтра `Encrypt`, потому что они тоже являются *зеркальными отражениями* друг друга.

I> Вы могли заметить странный фильтр `StaticFilter`, который не наследуется от базового класса
I> `AbstractFilter`. Это потому, что класс `StaticFilter` на самом деле являются "оберткой" (то есть,
I> "заместителем" (proxy) для другого фильтра без явного инстанцирования второго). 

Стандартные фильтры, предоставляемые компонентом `Zend\Filter`, вместе с их кратким описанием перечислены в таблице 8.1.

Как видите из этой таблицы, стандартные фильтры можно приблизительно разделить на следующие группы:

 * Фильтры для приведения типов входных данных (integer, boolean, дата/время и пр.);
 * фильтры, обрабатывающие путь файла (получение имени базы, имени родительской директории и т.д.);
 * фильтры, осуществляющие сжатие и шифрование входных данных;
 * фильтры, управляющие строковыми данными (изменение регистра, удаление пробелов, замена и удаление символов, нормализация URL и д.р.); и
 * фильтры-заместители - обертки для других фильтров (`Callback`, `FilterChain` и `StaticFilter`).

{title="Таблица 8.1. Стандартные фильтры"}
|--------------------------------|---------------------------------------------------------------|
| *Имя класса*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `ToBoolean`                    | Возвращает булевое представление `$value`.                    |
|--------------------------------|---------------------------------------------------------------|
| `ToInt`                        | Приводит входные данные `$value` к типу `int`.               |
|--------------------------------|---------------------------------------------------------------|
| `Digits`                       | Возвращает строку `$value`, удаляя все символы кроме цифр.    |
|--------------------------------|---------------------------------------------------------------|
| `ToNull`                       | Возвращает `null`, если значение входных данных может трактоваться как null; иначе возвращает `$value`. |
|--------------------------------|---------------------------------------------------------------|
| `DateTimeFormatter`            | Принимает строку даты/времени в произвольном формате и создает строку даты/времени в заданном формате. |
|--------------------------------|---------------------------------------------------------------|
| `BaseName`                     | Принимая строку, содержащую путь к файлу или каталогу, этот фильтр вернет последний компонент имени. |
|--------------------------------|---------------------------------------------------------------|
| `Dir`                          | Принимая строку, содержащую путь к файлу или каталогу, этот фильтр вернет путь родительского каталога. |
|--------------------------------|---------------------------------------------------------------|
| `RealPath`                     | Возвращает каноническое абсолютное имя пути.                  |
|--------------------------------|---------------------------------------------------------------|
| `Compress`                     | Сжимает входные данные с помощью указанного алгоритма (по умолчанию GZ). |
|--------------------------------|---------------------------------------------------------------|
| `Decompress`                   | Разжимает входные данные с помощью указанного алгоритма (эффект противоположен фильтру `Compress`). |
|--------------------------------|---------------------------------------------------------------|
| `Encrypt`                      | Зашифровывает входные данные указанным алгоритмом шифрования. |
|--------------------------------|---------------------------------------------------------------|
| `Decrypt`                      | Расшифровывает входные данные, зашифрованные указанным алгоритмом шифрования. |
|--------------------------------|---------------------------------------------------------------|
| `Inflector`                    | Изменяет слово для выражения различных грамматических категорий: времени, наклонения, залога, вида глагола, лица, числа, пола и падежа. |
|--------------------------------|---------------------------------------------------------------|
| `PregReplace`                  | Выполняет поиск  и замену по регулярному выражению.         |
|--------------------------------|---------------------------------------------------------------|
| `StringToLower`                | Конвертирует строку в нижний регистр.                         |
|--------------------------------|---------------------------------------------------------------|
| `StringToUpper`                | Конвертирует строку в верхний регистр.                        |
|--------------------------------|---------------------------------------------------------------|
| `StringTrim`                   | Убирает пробельные символы (пробелы, табуляцию и пр.) из начала и из конца строки. |
|--------------------------------|---------------------------------------------------------------|
| `StripNewlines`                | Убирает из строки символы перехода на новую строку (ASCII-коды #13, #10). |
|--------------------------------|---------------------------------------------------------------|
| `HtmlEntities`                 | Возвращает строку, конвертируя символы в соответствующие      |
|                                | HTML-сущности (где таковые существуют).                       |
|--------------------------------|---------------------------------------------------------------|
| `StripTags`                    | Убирает теги (например, `<a></a>`) и комментарии (например, `<!-- -->`).|
|--------------------------------|---------------------------------------------------------------|
| `UriNormalize`                 | Конвертирует строку URL в "нормализованную" форму и добавляет перед схемой (например, конвертирует *www.example.com* в *http://www.example.com*). |
|--------------------------------|---------------------------------------------------------------|
| `Callback`                     | Позволяет использовать функцию обратного вызова в качестве фильтра. |
|--------------------------------|---------------------------------------------------------------|
| `FilterChain`                  | Позволяет организовать несколько фильтров в цепь.             |
|--------------------------------|---------------------------------------------------------------|
| `StaticFilter`                 | Возвращает значение, отфильтрованное указанным классом фильтра, |
|                                | без необходимости отдельного инстанцирования объекта фильтра. |
|--------------------------------|---------------------------------------------------------------|

## Инстанцирование фильтра

В Zend Framework 3 фильтр можно создать несколькими способами: 

 * инстанцировать его вручную (с помощью оператора `new`);
 * создать его с помощью класса фабрики (передав описание в виде массива), 
   этот способ чаще всего используется при добавлении в форму правил фильтрации и валидации; и
 * инстанцировать его неявно с помощью класса-обертки `StaticFilter`.

Далее мы рассмотрим эти три способа более детально. 

### Способ 1: Инстанцирование фильтра вручную

Как мы уже сказали, фильтр, в целом, можно использовать не только с формами, но и для фильтрации
произвольных данных. Чтобы это сделать, просто создайте экземпляр класса фильтра, настройте фильтр
с помощью предоставляемых им методов и вызовите метод `filter()`.

Рассмотрим, например, использование фильтра `StringTrim`, который убирает пробелы
из начала и из конца строки.

I> Фильтр `StringTrim` полезен для фильтрации введенных пользователем строковых данных (адреса эл. почты, имена 
I> пользователей и т.д.), потому что посетители сайтов часто в них опечатываются. Например, пользователь
I> может случайно ввести пробел в конце поля электронного адреса, что сделает адрес недействительным. С 
I> помощью фильтра `StringTrim` вы легко сможете справиться с такими ошибками ввода и тем самым повысите качество обслуживания пользователей.

Методы, представленные этим фильтром, перечислены в таблице 8.2:

{title="Таблица 8.2. Public-методы фильтра StringTrim"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода *                  | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($charlistOrOptions)` | Конструктор фильтра. Принимает список опций.               |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Удаляет предопределенные символы из начала и из конца строки. |
|--------------------------------|---------------------------------------------------------------|
| `setCharList($charList)`       | Определяет список символов, которые нужно убрать.             |
|--------------------------------|---------------------------------------------------------------|
| `getCharList()`                | Возвращает список символов, которые нужно убрать.             |
|--------------------------------|---------------------------------------------------------------|

Как видите из таблицы выше, фильтр `StringTrim`, вдобавок к методу `filter()`, предоставляет
метод конструктора, которому вы можете при желании передать полный список опций для инициализации фильтра,
и методы `setCharList()` и `getCharList()`, которые могут быть использованы для задания указанных опций фильтра.

I> У всех стандартных фильтров есть метод конструктора, принимающий (опционально) массив опций
I> для настройки фильтра при его инстанцировании вручную. 

Ниже мы приведем два примера кода, демонстрирующие эквивалентные способы создания экземпляра `StringTrim`
вручную, задания его опций и фильтрации значения.

**Пример 1. Передача опций методу конструктора.**

{line-numbers=on, lang=php}
~~~
<?php
// Определяем псевдоним для имени класса фильтра (опционально).
use Zend\Filter\StringTrim;

// Создаем экземпляр фильтра, передавая опции конструктору.
$filter = new StringTrim(['charlist'=>"\r\n\t "]);

// Выполняем операцию удаления пробелов из начала и конца строки.
$filteredValue = $filter->filter(' name@example.com  ');

// Ожидаемый вывод фильтра - строка 'name@example.com'.
~~~

В этом фрагменте кода мы создали объект фильтра `StringTrim` с помощью оператора 
`new` (строка 6). Мы передаем массив опций конструктора для задания списка символов,
которые будут удалены фильтром (в этом примере мы сообщаем фильтру, что нужно удалять
символы перевода строки, символы табуляции и пробелы). Вообще, передачу массива опций
этому фильтру можно пропустить, так как у него уже есть стандартный список символов,
которые нужно убирать.

В строке 9 мы вызываем метод `filter()` и передаем ему строковое значение " name@example.com  ",
из которого хотим убрать пробелы. Ожидаемый результат этого вызова - строка "name@example.com".

**Пример 2. Без передачи опций конструктору.**

{line-numbers=on, lang=php}
~~~
<?php
// Определяем псевдоним для имени класса фильтра (опционально).
use Zend\Filter\StringTrim;

// Создаем экземпляр фильтра.
$filter = new StringTrim();

// Указываем, какие символы надо удалять.
$filter->setCharList("\r\n\t ");

// Выполняем операцию удаления пробелов из начала и конца строки.
$filteredValue = $filter->filter(' name@example.com  ');

// Ожидаемый вывод фильтра - строка 'name@example.com'.
~~~

Во фрагменте выше мы создаем объект фильтра `StringTrim` с помощью оператора `new`
(строка 6).

В строке 9, мы (опционально) вызываем метод `setCharList()` фильтра `StringTrim` для задания списка
символов, которые фильтр будет удалять (в нашем примере мы сообщаем фильтру, что нужно удалять
символы перевода строки, символы табуляции и пробелы). Вызывать этот метод необязательно, так как
у фильтра уже есть стандартный список символов, которые нужно убирать.

Наконец, в строке 12 мы вызываем метод `filter()` и передаем ему строковое значение " name@example.com  ",
из которого хотим убрать пробелы. Ожидаемый результат этого вызова - строка "name@example.com".

### Способ 2: Создание фильтра с помощью StaticFilter

Альтернативный способ ручного инстанцирования фильтра - с использованием класса `StaticFilter`. 
Класс `StaticFilter` - что-то вроде "заместителя" ("proxy"), который предназначен для автоматического 
инстанцирования фильтра, настройки и выполнения. Рассмотрим, например, как создать 
тот же фильтр `StringTrim`, настроить его и вызывать его метод `filter()`:

{line-numbers=on, lang=php}
~~~
<?php
// Создание и выполнение фильтра StringTrim через "заместителя" StaticFilter.
$filteredValue = \Zend\Filter\StaticFilter::execute(' name@example.com  ', 
                        'StringTrim', ['charlist' => "\r\n\t "]);
						
// Ожидаемый вывод фильтра - строка 'name@example.com'.
~~~

Класс `StaticFilter` предоставляет метод `execute()`, который принимает три 
аргумента: входное значение, имя фильтра, который нужно применить, и массив
опций для выбранного фильтра. 

В строке 3 мы вызываем метод `execute()`, чтобы автоматически создать фильтр `StringTrim`,
вызвать его метод `setCharList()` и передать входное значение методу `filter()`. 
Это крайне полезно, так как может быть выполнено в одну строчку кода.

### Способ 3: Создание фильтра из массива

При использовании фильтров для правил валидации формы, как правило, объект
фильтра не создают явно, как мы сделали это в предыдущем разделе; вместо этого
настройки передаются в виде массива классу фабрики, который автоматически создает
фильтр. Мы уже сталкивались с подобным способом
при добавлении правил валидации для формы обратной связи в главе
[Сбор пользовательских данных с помощью форм](#forms).

В качестве примера покажем, как создать все тот же фильтр `StringTrim` с 
помощью фабрики:

{line-numbers=on, lang=php}
~~~
<?php
// Предполагается, что вы вызываете следующий код внутри метода
// addInputFilter() модели формы.

$inputFilter->add([
  // ...  
  'filters'  => [
    [
      'name' => 'StringTrim',
      'options' => [
        'charlist' => "\r\n\t "
      ]	  
    ],
  ],                
  // ...
];
~~~

В фрагменте кода выше мы вызываем метод `add()`, предоставляемый классом-контейнером `InputFilter` (строка 5).
Метод `add()` принимает массив, который имеет ключ `filters`. Как правило, фильтры регистрируются
под этим ключом (строка 7). Фильтры, зарегистрированные под этим ключом, вставляются в цепь фильтров
в том же порядке, что и в списке.

Конфигурация фильтра обычно состоит из имени - `name`  (строка 9) и опций - `options` (строка 10). Имя - 
это полностью определенное имя класса фильтра (например, `Zend\Filter\StringTrim`), либо его 
псевдоним (`StringTrim`). `options` - это массив, состоящий из опций конкретного фильтра. Когда
класс фабрики инстанцирует фильтр, он передает список опций методу конструктора фильтра, а конструктор 
при необходимости инициализирует фильтр.

## О менеджере плагинов фильтров

В предыдущем примере вы видели, что при инстанцировании фильтра из массива можно использовать либо полностью 
определенное имя класса фильтра, либо его псевдоним. Псевдонимы для стандартных фильтров определяются классом
`FilterPluginManager`.

I> Класс `FilterPluginManager` определяет псевдонимы для стандартных фильтров.

Псевдоним стандартного фильтра, как правило, такой же, как и имя класса. Например, у
класса `Zend\Filter\StringTrim` псевдоним - `StringTrim`.

Менеджер плагинов фильтров внутренне используется классом-контейнером `InputFilter` для
инстанцирования стандартных фильтров.

## Поведение фильтра в случае некорректных входных данных

Разные фильтры ведут себя по-разному, когда вы передаете им входные данные, которые фильтр не может
корректно обработать.

Некоторые фильтры (такие как `ToInt`) будут обрабатывать только скалярные данные. Если вы передадите
такому фильтру массив, он вернет вам массив как есть.

Некоторые фильтры могут работать только с данными в определенном формате (например, только с датами). Если
фильтрация входных данных невозможна (например, при передаче фильтру неверных данных, которые он не в состоянии
обработать), метод `filter()` может выбросить исключение `Zend\Form\Exception\RuntimeException`.
Такое поведение можно наблюдать в фильтре `DateTimeFormatter`.

Некоторые фильтры (например, `ToInt` или `StringToLower`) могут выдать PHP-предупреждение, если
значение предоставлено в некорректном формате и не может быть отфильтровано.

T> Рекомендуется внимательно читать документацию фильтра, чтобы знать, чего ожидать 
T> от фильтра, который вы планируете использовать в своей форме.

## Примеры использования фильтров

Далее мы рассмотрим примеры использования самых важных стандартных фильтров. Мы
опишем методы (и опции) фильтра и приведем фрагменты кода, показывающие, как
инстанцировать фильтр и применить его к входным данным. Если вам нужно использовать
фильтр, не рассматриваемый в этом разделе, обратитесь к разделу *Стандартные фильтры*
*Справочного руководства Zend Framework*.

### Фильтры, приводящие входные данные к определенному типу
 
В этом разделе мы расскажем о нескольких фильтрах из группы фильтров, связанных
с приведением входных данных к определенному типу, и приведем примеры их использования.

#### Фильтр ToInt

Фильтр `ToInt` - очень простой фильтр, предназначенный для приведения произвольных
скалярных данных к типу integer. Этот фильтр может быть полезен при добавлении правил
валидации для полей формы, которые должны содержать числовые значения типа integer (например,
выпадающий список или текстовое поле, содержащее количество чего-либо).

Класс `ToInt` имеет единственный метод `filter()`.

I> Фильтр `ToInt` не будет приводить нескалярные значения. Если вы передадите ему массив,
I> он вернет его как есть.

Ниже показан пример кода, демонстрирующий использование фильтра `ToInt`.

{line-numbers=on, lang=php}
~~~
<?php
// Создаем фильтр ToInt.
$filter = new \Zend\Filter\ToInt();

// Фильтруем значение, приводя его к типу integer.
$filteredValue = $filter->filter('10'); // Возвращает (int) 10.
$filteredValue2 = $filter->filter(['10', '20']); // Возвращает массив как есть.
~~~

Во фрагменте выше мы передаем фильтру строку "10" (строка 6). Ожидаемое возвращаемое
значение - 10 (типа integer).

В строке 7 мы передаем фильтру массив. Так как фильтр `Int` работает только со скалярными значениями,
он возвращает массив как есть (без изменений) и выдает PHP-предупреждение.

#### Фильтр ToBoolean

Класс `ToBoolean` - это фильтр, предназначенный для приведения произвольных данных к булевому значению
(`true` или `false`). Этот фильтр может использоваться для фильтрации полей формы флажка.

Его public-методы перечислены в таблице 8.3.

{title="Таблица 8.3. Public-методы фильтра ToBoolean"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Возвращает булевое представление `$value`.                    |
|--------------------------------|---------------------------------------------------------------|
| `setCasting($flag)`            | Устанавливает флаг приведения.                                |
|--------------------------------|---------------------------------------------------------------|
| `getCasting()`                 | Возвращает флаг приведения.                                   |
|--------------------------------|---------------------------------------------------------------|
| `setType($type)`               | Задает типы, которые нужно приводить.                         |
|--------------------------------|---------------------------------------------------------------|
| `getType()`                    | Возвращает типы.                                              |
|--------------------------------|---------------------------------------------------------------|
| `setTranslations($translations)`| Задает переводы.                                             |
|--------------------------------|---------------------------------------------------------------|
| `getTranslations()`            | Возвращает переводы.                                          |
|--------------------------------|---------------------------------------------------------------|

Этот фильтр предоставляет несколько методов, позволяющих задать опции фильтрации (`setCasting()`, `setType()`,
и `setTranslations()`).

Метод `setCasting()` позволяет выбрать один из двух режимов работы фильтра. Если флаг установлен
в значение true, фильтр будет вести себя как оператор приведения PHP (к типу `boolean`). Иначе
(если флаг установлен в значение `false`), он будет приводить только типы, определенные методом
`setType()`, а другие значения возвращать как есть.

Метод фильтра `setType()` позволяет определить, какие типы нужно приводить. Этот метод принимает
один аргумент `$type`, который может быть либо комбинацией ИЛИ констант с префиксом `TYPE_`, либо
массивом, содержащим буквенные эквиваленты констант. Константы, принимаемые методом, и их
буквенные эквиваленты перечислены в таблице 8.4:

{title="Таблица 8.4. Константы типов"}
|----------------------|--------------------|----------------------|----------------------------------------|
| *Константа*          | *Числовое значение*| *Буквенный эквивалент*| *Описание*                            |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_BOOLEAN`       | 1                  | "boolean"            | Возвращает булевое значение как есть.  |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_INTEGER`       | 2                  | "integer"            | Конвертирует integer-значение 0 в `false`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_FLOAT`         | 4                  | "float"              | Конвертирует float-значение 0.0 в `false`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_STRING`        | 8                  | "string"             | Конвертирует пустую строку '' в `false`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_ZERO_STRING`   | 16                 | "zero"               | Конвертирует строку, содержащую один символ нуля ('0') в `false`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_EMPTY_ARRAY`   | 32                 | "array"              | Конвертирует пустой массив в `false`.  |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_NULL`          | 64                 | "null"               | Конвертирует значение `null` в `false`.|
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_PHP`           | 127                | "php"                | Конвертирует значения согласно PHP при приведении к типу boolean. (Это поведение по умолчанию.) |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_FALSE_STRING`  | 128                | "false"              | Конвертирует строку, содержащую слово "false" в булевое `false`. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_LOCALIZED`     | 256                | "localized"          | Конвертирует локализованную строку, которая содержит определенное слово, в boolean. |
|----------------------|--------------------|----------------------|----------------------------------------|
| `TYPE_ALL`           | 511                | "all"                | Конвертирует все вышеперечисленные типы в boolean. |
|----------------------|--------------------|----------------------|----------------------------------------|

Следующий пример кода показывает два эквивалентных способа вызова метода `setType()`:

{line-numbers=off, lang=php}
~~~
<?php
use Zend\Filter\ToBoolean;

// Вызываем метод setType() и передаем ему комбинацию констант.
$filter->setType(ToBoolean::TYPE_BOOLEAN|
                 ToBoolean::TYPE_INTEGER|
                 ToBoolean::TYPE_STRING);

// Вызываем метод setType() и передаем ему массив буквенных эквивалентов.
$filter->setType(['boolean', 'integer', 'string']);
~~~

Метод `setTranslations()` позволяет определить локализованные эквиваленты булевых значений
`true` и `false`. Этот принимает один параметр, который должен быть массивом в виде пар *ключ=>значение*,
где *ключ* - локализованная строка, а *значение* - его булевое представление. Следующий пример кода 
показывает, как использовать метод `setTranlsations()`:

{line-numbers=off, lang=php}
~~~
<?php
$filter->setTranslations([
  'yes' => true,    // Английское 'да'
  'no'  => false,   // Английское 'нет'
  'ja'  => true,    // Немецкое 'да'
  'nicht' => false, // Немецкое 'нет'
  'да'  => true,    // Русское 'да'
  'нет' => false    // Русское 'нет'
  ]);
~~~

Ниже приведен фрагмент кода, демонстрирующий использование фильтра `ToBoolean`.

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр ToBoolean.
$filter = new \Zend\Filter\ToBoolean();

// Настраиваем фильтр (опционально).
$filter->setCasting(true);
$filter->setType(\Zend\Filter\ToBoolean::TYPE_ALL);
$filter->setTranslations(['yes'=>true, 'no'=>false]);

// Фильтруем значение, приводя его к типу boolean.
$filteredValue = $filter->filter('false'); // Возвращает булевое false.
$filteredValue2 = $filter->filter('1'); // Возвращает булевое true.
$filteredValue3 = $filter->filter('false'); // Возвращает булевое false.
$filteredValue4 = $filter->filter('yes'); // Возвращает булевое true.
~~~

#### Фильтр ToNull

Фильтр `ToNull` предназначен для приведения произвольных данных к значению `null`, если они отвечают
определенным критериям. Это может быть полезно, когда вы работаете с базой данных и хотите использовать
для значения тип `null` вместо любого другого типа. Если значение нельзя трактовать как NULL, фильтр
вернет значение как есть.

Public-методы фильтра `ToNull` перечислены в таблице 8.5.

{title="Таблица 8.5. Public-методы фильтра ToNull"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Приводит `$value` к `null`, если это возможно; иначе возвращает значение как есть. |
|--------------------------------|---------------------------------------------------------------|
| `setType($type)`               | Определяет, какие типы нужно приводить.                       |
|--------------------------------|---------------------------------------------------------------|
| `getType()`                    | Возвращает определенные типы.                                 |
|--------------------------------|---------------------------------------------------------------|

По умолчанию фильтр `ToNull` ведет себя как PHP-функция `empty()`: если эта функция возвращает
булевое `true` при передаче ей входных данных, то фильтр также вернет значение `null` при этих
данных.

Метод `setType()` может быть использован для задания типа, который фильтр будет приводить к `null`.
Этот метод принимает один параметр, который может быть либо комбинацией ИЛИ констант с префиксом `TYPE_`, 
перечисленных в таблице 8.6, либо массивом их буквенных эквивалентов.

{title="Таблица 8.6. Константы типов"}
|---------------------|-----------------|----------------------|----------------------------------------|
| *Константа*         | *Числовое значение* | *Буквенный эквивалент* | *Описание*                       |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_BOOLEAN`      | 1               | "boolean"            | Конвертирует булевое значение `false` в `null`. |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_INTEGER`      | 2               | "integer"            | Конвертирует integer-значение 0 в `null`. |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_EMPTY_ARRAY`  | 4               | "array"              | Конвертирует пустой массив в `null`.   |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_STRING`       | 8               | "string"             | Конвертирует пустую строку '' в `null`.|
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_ZERO_STRING`  | 16              | "zero"               | Конвертирует строку, содержащую один символ нуля  ('0') в `null`. |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_FLOAT`        | 32              | "float"              | Конвертирует float-значение 0.0 в `null`. |
|---------------------|-----------------|----------------------|----------------------------------------|
| `TYPE_ALL`          | 63              | "all"                | Конвертирует все вышеперечисленные типы в `null`. Это поведение по умолчанию. |
|---------------------|-----------------|----------------------|----------------------------------------|

Следующий пример кода демонстрирует два способа вызова метода `setType()`:

{line-numbers=off, lang=php}
~~~
<?php
use Zend\Filter\ToNull;

// Вызываем метод setType() и передаем ему комбинацию констант.
$filter->setType(ToNull::TYPE_ZERO_STRING|Null::TYPE_STRING);

// Вызываем метод setType() и передаем ему массив буквенных эквивалентов.
$filter->setType(['zero', 'string']);
~~~

Ниже приведен фрагмент кода, показывающий, как использовать фильтр `ToNull`:

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр ToNull.
$filter = new \Zend\Filter\ToNull();

// Настраиваем фильтр (опционально).
$filter->setType(\Zend\Filter\ToNull::TYPE_ALL);

$filteredValue = $filter->filter('0'); // Возвращает null.
$filteredValue2 = $filter->filter('1'); // Возвращает строку string '1'.
$filteredValue3 = $filter->filter(false); // Возвращает null.
~~~

#### Фильтр DateTimeFormatter
 
Фильтр `DateTimeFormatter` принимает дату в произвольном формате и конвертирует
в желаемый формат. 

I> Этот фильтр может принимать строку (например, '2014-03-22 15:36'), метку времени типа integer 
I> (такую, как возвращает PHP-функция `time()`) или экземпляр PHP-класса `DateTime`. 
I> Фильтр `DateTimeFormatter` может выбрасывать исключение `Zend\Filter\Exception\InvalidArgumentException`, 
I> если вы передадите ему дату в некорректном формате.

Public-методы этого фильтра перечислены в таблице 8.7.

{title="Таблица 8.7. Public-методы фильтра DateTimeFormatter"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Преобразовывает дату в желаемый формат.                       |
|--------------------------------|---------------------------------------------------------------|
| `setFormat($format)`           | Задает формат даты.                                           |
|--------------------------------|---------------------------------------------------------------|

Во фрагменте кода ниже мы покажем, как создать фильтр, передать ему дату в виде строки и
конвертировать ее в желаемый формат.

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр DateTimeFormatter.
$filter = new \Zend\Filter\DateTimeFormatter();

// Задаем формат фильтра (опционально).
$filter->setFormat('F j, Y g:i A');

// Преобразовываем дату в указанный формат.
$filteredValue = $filter->filter('2014-03-22 15:36');

// Ожидаемый результат - 'March 22, 2014 3:36 PM'.
~~~

I> Фильтр `DateTimeFormatter` внутренне использует класс `DateTime` из стандартной библиотеки
I> PHP для конвертации и форматирования дат. Доступные форматы дат вы можете посмотреть в
I> документации класса `DateTime`.
 
### Фильтры, выполняющие манипуляции с путем файла

В этом разделе мы рассмотрим примеры использования фильтров из группы фильтров, связанных
с обработкой путей файлов.

#### Фильтр BaseName

Класс фильтра `BaseName` - это лишь обертка  PHP-функции `basename()`. 
Он принимает строку, содержащую путь к файлу или каталогу, и возвращает
последний компонент имени.

Ниже показан пример использования фильтра `BaseName`.

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр BaseName.
$filter = new \Zend\Filter\BaseName();

// Фильтруем путь файла и возвращаем его последнюю часть.
$filteredValue = $filter->filter('/var/log/httpd/error.log');

// Ожидаемый вывод фильтра - 'error.log'.
~~~

I> Фильтр `BaseName` не будет обрабатывать нескалярное значение. Если вы передадите
I> ему массив, он вернет его как есть и выдаст PHP-предупреждение.

#### Фильтр Dir

Класс фильтра `BaseName` - это лишь обертка  PHP-функции `dirname()`. 
Он принимает строку, содержащую путь к файлу или каталогу, и возвращает
путь родительского каталога.

I> Фильтр `Dir` не будет обрабатывать нескалярное значение. Если вы передадите
I> ему массив, он вернет его как есть.

Фрагмент кода ниже демонстрирует пример использования фильтра `Dir`.

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр Dir.
$filter = new \Zend\Filter\Dir();

// Фильтруем путь файла и возвращаем имя его каталога.
$filteredValue = $filter->filter('/var/log/httpd/error.log');

// Ожидаемый вывод фильтра - '/var/log/httpd'.
~~~

#### Фильтр RealPath

Фильтр `RealPath` принимает абсолютный или относительный путь к файлу в виде строкового аргумента.
Он раскрывает все символические ссылки, переходы типа '/./', '/../' и лишние символы '/' в пути,
возвращая канонизированный абсолютный путь к файлу.

I> Фильтр `RealPath` - это обертка PHP-функции `realpath()`.

Public-методы фильтра перечислены в таблице 8.8.

{title="Таблица 8.8. Public-методы фильтра RealPath"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Вовращает канонизированный абсолютный путь к файлу.           |
|--------------------------------|---------------------------------------------------------------|
| `setExists($flag)`             | Указывает, должен ли существовать путь для успешной работы фильтра.  |
|                                | Значение `true` означает, что путь должен существовать; значение `false` |
|                                | означает, что можно передать несуществующий путь.             |
|--------------------------------|---------------------------------------------------------------|
| `getExists()`                  | Возвращает `true`, если фильтруемый путь должен существовать. |
|--------------------------------|---------------------------------------------------------------|

Фильтр `RealPath` возвращает булевое `false` при неудаче, например, если файла не существует.
Если несуществующий путь разрешен, вы можете вызвать метод `setExists()` с параметром `false`.

Фрагмент кода ниже демонстрирует пример использования фильтра `RealPath`.

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр RealPath.
$filter = new \Zend\Filter\RealPath();

// Фильтруем путь к файлу (предполагается, что текущий
// рабочий каталог - /var/log/httpd, и что он содержит 
// файл error.log).
$filteredValue = $filter->filter('./error.log');

// Ожидаемый вывод фильтра - '/var/log/httpd/error.log'.
~~~

I> Фильтр `RealPath` не будет обрабатывать нескалярное значение. Если вы передадите
I> ему массив, он вернет его как есть.

### Фильтры, осуществляющие сжатие и шифрование входных данных

В этом разделе мы рассмотрим несколько фильтров из группы фильтров, связанных
со сжатием и шифрованием входных данных. Эти фильтры не особо подходят для
фильтрации данных форм, но могут с большим успехом использоваться вне форм.

#### Фильтр Compress

Фильтр `Compress` предназначен для сжатия входных данных с помощью некоторого алгоритма сжатия.
Например, этот фильтр можно использовать, чтобы сжать данные и сохранить их в виде архива.

Public-методы фильтра перечислены в таблице 8.9.

{title="Таблица 8.9. Public-методы фильтра Compress"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Производит сжатие данных, используя указанный алгоритм.       |
|--------------------------------|---------------------------------------------------------------|
| `getAdapter()`                 | Возвращает текущий адаптер, инстанцируя его, если необходимо. |
|--------------------------------|---------------------------------------------------------------|
| `getAdapterName()`             | Извлекает имя адаптера.                                       |
|--------------------------------|---------------------------------------------------------------|
| `setAdapter($adapter)`         | Задает адаптер сжатия.                                        |
|--------------------------------|---------------------------------------------------------------|
| `getAdapterOptions()`          | Извлекает опции адаптера.                                     |
|--------------------------------|---------------------------------------------------------------|
| `setAdapterOptions($options)`  | Задает опции адаптера.                                        |
|--------------------------------|---------------------------------------------------------------|
| `getOptions($option)`          | Получает отдельную или все опции используемого адаптера.      |
|--------------------------------|---------------------------------------------------------------|

Сам фильтр `Compress` не может сжимать данные. Вместо этого он использует так называемый
класс *адаптера*. Класс адаптера должен реализовывать интерфейс `CompressionAlgorithmInterface`.
Вы добавляете адаптер к фильтру `Compress`, и адаптер реализует определенный алгоритм сжатия.

Существует несколько стандартных классов адаптеров (см. рисунок 8.2 и таблицу 8.10). Эти классы
"живут" в пространстве имен `Zend\Filter\Compress`.

{title="Таблица 8.10. Адаптеры сжатия"}
|--------------------------------|---------------------------------------------------------------|
| *Class name*                   | *Description*                                                 |
|--------------------------------|---------------------------------------------------------------|
| `Bz2`                          | [Bzip2](http://www.bzip.org/) - алгоритм сжатия Барроуза-Уилера. |
|--------------------------------|---------------------------------------------------------------|
| `Gz`                           | Алгоритм сжатия [Gzip](http://www.gzip.org/) основан на алгоритме Deflate, являющимся комбинацией алгоритма LZ77 и кодирования Хаффмана. |
|--------------------------------|---------------------------------------------------------------|
| `Zip`                          | ZIP - алгоритм сжатия, широко используемый в операционной системе Windows. |
|--------------------------------|---------------------------------------------------------------|
| `Tar`                          | Формат файла [Tarball](http://www.gnu.org/software/tar/tar.html) обычно используется, чтобы собрать много файлов в один большой для архивирования, сохраняя информацию файловой системы: права пользователя/группы, даты и структуры каталогов. Широко используется в операционной системе Linux.
|--------------------------------|---------------------------------------------------------------|
| `Lzf`                          | LZF - очень быстрый алгоритм сжатия, идеальный для экономии пространства без большого ущерба для скорости. |
|--------------------------------|---------------------------------------------------------------|
| `Snappy`                       | [Snappy](https://code.google.com/p/snappy/) - основанная на идея LZ77 библиотека для быстрого сжатия и распаковки данных, разработанная Google. |
|--------------------------------|---------------------------------------------------------------|
| `Rar`                          | RAR - формат архива, поддерживающий сжатие данных, устранение ошибок и разделение одного файла на несколько. |
|--------------------------------|---------------------------------------------------------------|

![Рисунок 8.2. Наследование адаптеров алгоритмов сжатия](../en/images/filters/compression_algorithm_inheritance.png)
 
Фрагмент кода ниже демонстрирует пример использования фильтра `Compress`.

{line-numbers=on, lang=php}
~~~
<?php
// Создаем фильтр Compress.
$filter = new \Zend\Filter\Compress();

// Настраиваем адаптер.
$filter->setAdapter('Zip');
$filter->setAdapterOptions([
        'archive' => 'example.zip',
    ]);

// Сжимаем входные данные (предполагается, что в текущем рабочем каталоге 
// находится файл testfile.txt ).
$filter->filter('testfile.txt');
~~~

В примере выше мы создаем экземпляр фильтра `Compress (строка 3), задаем его адаптер (строка 6),
задаем опции адаптера (строка 7) и затем сжимаем входной файл (строка 13). Ожидаемый результат,
файл архива *example.zip*, будет создан в текущем каталоге. Архив будет содержать файл *testfile.txt*.

I> Фильтр `Decompress` является "зеркальным отражением" фильтра `Compress` и используется 
I> аналогично. По этой причине мы не будем рассматривать фильтр `Decompress` в этом разделе.

#### Фильтр Encrypt

Задача фильтра `Encrypt` - шифрование входных данных с помощью указанного алгоритма.
Public-методы фильтра перечислены в таблице 8.11.

{title="Таблица 8.11. Public-методы фильтра Encrypt"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Производит шифрование данных, используя указанный алгоритм.   |
|--------------------------------|---------------------------------------------------------------|
| `getAdapter()`                 | Возвращает текущий адаптер, инстанцируя его, если необходимо. |
|--------------------------------|---------------------------------------------------------------|
| `setAdapter($adapter)`         | Задает адаптер сжатия.                                        |
|--------------------------------|---------------------------------------------------------------|

Фильтр `Encrypt` использует классы *адаптеров* для непосредственной шифровки данных. Вы добавляете 
адаптер к фильтру `Encrypt` с помощью метода `setAdapter()`, и адаптер производит определенное шифрование.
Класс адаптера должен реализовывать интерфейс `EncryptionAlgorithmInterface`.

Существует несколько стандартных классов адаптеров (см. рисунок 8.3). Эти классы
"живут" в пространстве имен `Zend\Filter\Encrypt`.

 * `BlockCipher` -- реализует симметричный блочный алгоритм шифрования.
 * `Openssl` -- использует алгоритм шифрования из библиотеки OpenSSL.

![Рисунок 8.3. Наследование адаптеров алгоритмов шифрования](../en/images/filters/encryption_algorithm_inheritance.png)

Фрагмент кода ниже демонстрирует пример использования фильтра `Encrypt`.

{line-numbers=on, lang=php}
~~~
<?php
// Создаем фильтр Encrypt.
$filter = new \Zend\Filter\Encrypt();

// Задаем адаптер шифрования.
$filter->setAdapter('BlockCipher');

// Зашифровываем входные данные.
$filteredValue = $filter->filter('some data to encrypt');
~~~

Ожидаемые результат - строка, зашифрованная блочным шифром. 
 
I> Фильтр `Decrypt` является "зеркальным отражением" фильтра `Encrypt` и используется 
I> аналогично. По этой причине мы не будем рассматривать фильтр `Decrypt` в этом разделе.

### Фильтры, управляющие строковыми данными

В этом разделе мы рассмотрим примеры использования фильтров из группы фильтров,
связанных с изменением строковых данных.

#### Фильтр StringToLower

Класс фильтра `StringToLower` предназначен для преобразования входных строковых данных в символы
нижнего регистра. Public-методы фильтра представлены ниже в таблице 8.12.

{title="Таблица 8.12. Public-методы фильтра StringToLower"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Конвертирует строку в нижний регистр.                         |
|--------------------------------|---------------------------------------------------------------|
| `setEncoding($encoding)`       | Задает кодировку входных данных для заданной строки.          |
|--------------------------------|---------------------------------------------------------------|
| `getEncoding()`                | Возвращает кодировку.                                         |
|--------------------------------|---------------------------------------------------------------|

По умолчанию, фильтр работает как PHP-функция `strtolower()`. Принимая строковое значение, он возвращает 
строку, в которой все буквенные символы переведены в нижний регистр. Принадлежность символа к "буквенным" 
определяется локалью системы. Это значит, что, например, в стандартной локали "C" такие символы, как «а-умлаут» (Ä)
не будут конвертированы.

Вызов метода `setEncoding()` на фильтре и передача ему кодировки принуждает фильтр вести себя
как PHP-функция `mb_strtolower()`. В отличие от `strtolower()` то, что символ является буквой, 
определяется свойствами символа Юникода. Поэтому поведение этой функции не зависит от настроек
локали, и она может конвертировать любой символ, определяемый в Юникоде как "буква", например, «а-умлаут» (Ä).

I> Если представленное значение нескалярное, оно останется неотфильтрованным,
I> и будет выдано предупреждение `E_USER_WARNING`, указывающее на то, что значение не может быть отфильтровано.

Фрагмент кода ниже показывает, как использовать фильтр `Encrypt`:

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр StringToLower.
$filter = new \Zend\Filter\StringToLower();

// Задаем кодировку для фильтра (опционально).
$filter->setEncoding('UTF-8');

// Фильтруем строку.
$filteredValue = $filter->filter('How to Start a Business in 10 Days');

// Ожидаемый вывод фильтра - 'how to start a business in 10 days'.
~~~

I> Фильтр `StringToUpper` (перед строки в верхний регистр) является "зеркальным отражением" фильтра `StringToLower` и 
I> используется аналогично. По этой причине мы не будем рассматривать фильтр `StringToUpper` в этом разделе. 

#### Фильтр PregReplace

Фильтр `PregReplace` может быть использован для поиска и замены строковых данных по регулярному выражению.
Этот фильтр - обертка PHP-функции `preg_replace()`. Public-методы этого фильтра представлены ниже в таблице 8.13.

{title="Таблица 8.13. Public-методы фильтра PregReplace"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Выполняет поиск и замену по регулярному выражению.            |
|--------------------------------|---------------------------------------------------------------|
| `setPattern($pattern)`         | Задает искомый шаблон. Это может быть либо строка, либо массив строк. |
|--------------------------------|---------------------------------------------------------------|
| `getPattern()`                 | Возвращает шаблон.                                             |
|--------------------------------|---------------------------------------------------------------|
| `setReplacement($replacement)` | Задает строку или массив строк, используемые в качестве замены. |
|--------------------------------|---------------------------------------------------------------|
| `getReplacement()`             | Получает установленное в данный момент значение замены.       |
|--------------------------------|---------------------------------------------------------------|

Фрагмент кода ниже показывает, как использовать фильтр `Encrypt`:

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр PregReplace.
$filter = new \Zend\Filter\PregReplace();

// Настраиваем фильтр.
$filter->setPattern("/\s\s+/");
$filter->setReplacement(' ');

// Фильтруем строку.
$filteredValue = $filter->filter('An example    with    multiple     spaces.');

// Ожидаемый вывод фильтра - 'An example with multiple spaces.'
~~~

#### Фильтр StripTags

Фильтр `StripTags` удаляет все теги (например, `<!-- -->`, `<p>`, `<h1>` или `<?php ?>`) из входной строки.
Он также позволяет явно определить теги, которые не должны быть удалены. Кроме этого, фильтр предоставляет
возможность указать, какие атрибуты всех и/или только определенных тегов разрешены.

Public-методы фильтра `StripTags` перечислены в таблице 8.14.

{title="Таблица 8.14. Public-методы фильтра StripTags"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор фильтра.                                          |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Возвращает значение, из которого удалены теги.                |
|--------------------------------|---------------------------------------------------------------|
| `getAttributesAllowed()`       | Возвращает список разрешенных атрибутов тегов.                |
|--------------------------------|---------------------------------------------------------------|
| `setAttributesAllowed($attributesAllowed)` | Задает список разрешенных атрибутов тегов.        |
|--------------------------------|---------------------------------------------------------------|
| `getTagsAllowed()`             | Возвращает список разрешенных тегов.                          |
|--------------------------------|---------------------------------------------------------------|
| `setTagsAllowed($tagsAllowed)` | Задает список разрешенных тегов.                               |
|--------------------------------|---------------------------------------------------------------|

Фрагмент кода ниже показывает, как использовать фильтр `StripTags`:

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр StripTags.
$filter = new \Zend\Filter\StripTags();

// Настраиваем фильтр.
$filter->setTagsAllowed(['p']);

// Фильтруем строку.
$filteredValue = $filter->filter(
  '<p>Please click the following <a href="example.com">link</a>.</p>');

// Ожидаемый вывод фильтра - 
// '<p>Please click the following link.</p>;'
~~~

I> `StripTags` не будет обрабатывать нескалярное значение. Если передать фильтру такое значение,
I> оно останется неотфильтрованным.

#### Фильтр StripNewlines

StripNewlines` - весьма простой фильтр, который возвращает входную строку без
символов перевода строки ("\r", "\n").

Фрагмент кода ниже показывает, как использовать фильтр `StripNewlines`:

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр StripNewlines.
$filter = new \Zend\Filter\StripNewlines();

// Фильтруем строку.
$filteredValue = $filter->filter("A multi line\r\n string");

// Ожидаемый вывод фильтра - 'A multi line string'.
~~~

I> `StripNewline` не будет обрабатывать нескалярное значение. Если передать фильтру такое значение,
I> оно останется неотфильтрованным.

#### Фильтр UriNormalize

Фильтр `UriNormalie` может использоваться для нормализации URL-строки и (опционально) применения к
ней схемы. Public-методы этого фильтра приведены ниже в таблице 8.15.

{title="Таблица 8.15. Public-методы фильтра UriNormalize"}
|------------------------------------|---------------------------------------------------------------|
| *Имя метода*                       | *Описание*                                                    |
|------------------------------------|---------------------------------------------------------------|
| `filter($value)`                   | Фильтрует URL, нормализуя его и применяя схему по умолчанию (если она задана). |
|------------------------------------|---------------------------------------------------------------|
| `setDefaultScheme($defaultScheme)` | Задает схему по умолчанию для использования при разборе URI, не имеющим схем.  |
|------------------------------------|---------------------------------------------------------------|
| `setEnforcedScheme($enforcedScheme)` | Задает схему для применения к URI, не имеющим схем.         |
|------------------------------------|---------------------------------------------------------------|

Процедура нормализации URL, как правило, состоит из следующих шагов:

1. Строка URL разбивается на части: схему, хост, номер порта, путь и запрос.
   Если у заданного URL нет схемы, используется схема по умолчанию.
2. Части схемы и хоста переводятся в нижний регистр.
3. Номер порта сверяется со списком разрешенных номеров, и, если он не принадлежит этому списку, номер порта убирается.
4. Путь URL фильтруется: удаляются лишние сегменты точек, декодируются любые
   URL-закодированные символы, а также URL-кодируется все, что должно быть закодировано.
5. Часть запроса очищается: URL-декодируется все, что не должно быть закодированным и URL-кодируется
   все остальное.

Правила нормализации URL могут отличаться для разных протоколов (схем). Если URL не содержит часть схемы, по умолчанию
присваивается схема `http`. Вы можете использовать метод `setDefaultScheme()` фильтра UriNormalize`, чтобы установить
схему по умолчанию для нормализации URL. Он принимает любую из следующих схем: `http`, `https`, `file`, `mailto`, 
`urn` и `tag`.
   
Кроме того, другой метод фильтра `UriNormalize, `setEnforcedScheme()`, позволяет переопределить
схему по умолчанию так называемой "принудительной" схемой, если заданный URL не имеет части схемы.
   
Фрагмент кода ниже показывает, как использовать фильтр `UriNormalize`:

{line-numbers=off, lang=php}
~~~
<?php
// Создаем фильтр UriNormalize.
$filter = new \Zend\Filter\UriNormalize();

// Настраиваем фильтр.
$filter->setDefaultScheme('http');
$filter->setEnforcedScheme('https');

// Фильтруем URL-строку.
$filteredValue = $filter->filter('www.example.com');

// Ожидаемый вывод фильтра - 'https://www.example.com/'.
~~~

### Организация фильтров в цепь

Фильтры могут быть организованы в последовательность. Это можно сделать с помощью класса `FilterChain`.
При запуске подобного составного фильтра, значение, отфильтрованное первым фильтром передается второму
в качестве входных данных, затем значение, отфильтрованное вторым фильтром передается третьему и так далее. 

I> Класс `FilterChain` внутренне используется классом-контейнером `InputFilter` для хранения
I> последовательности фильтров, присоединенных к полю модели формы.

Public-методы, предоставляемые классом `FilterChain`, представлены в таблице 8.16:

{title="Таблица 8.16. Public-методы фильтра FilterChain"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Возвращает значение, отфильтрованное каждым фильтром цепи. Фильтры запускаются в том же порядке, в котором были добавлены в цепь (FIFO - «первым пришёл — первым ушёл»). |
|--------------------------------|---------------------------------------------------------------|
| `setOptions($options)`         | Задает опции.                                                 |
|--------------------------------|---------------------------------------------------------------|
| `attach($callback, $priority)` | Добавляет к цепи существующий экземпляр фильтра (или функцию обратного вызова). |
|------------------------------------|---------------------------------------------------------------|
| `attachByName($name, $options, $priority)` | Инстанцирует фильтр по имени класса или псевдониму и вставляет его в цепь. |
|--------------------------------|---------------------------------------------------------------|
| `merge($filterChain)`          | Объединяет одну цепочку фильтров с другой.                       |
|--------------------------------|---------------------------------------------------------------|
| `getFilters()`                 | Возвращает все присоединенные фильтры                         |
|--------------------------------|---------------------------------------------------------------|
| `count()`                      | Возвращает количество присоединенных фильтров.                 |
|--------------------------------|---------------------------------------------------------------|

Пример цепочки фильтров показан на рисунке 8.4. Она состоит из фильтра `StringTrim`, за которым идет фильтр
`StripTags`, за которым в свою очередь следует фильтр `StripNewlines`.

![Рисунок 8.4. Цепь фильтров](../en/images/filters/filter_chain.png)

Для создания цепочки как на рисунке 8.4 мы используем следующий код:

{line-numbers=on, lang=php}
~~~
<?php
use Zend\Filter\FilterChain;

// Инстанцируем цепь фильтров.
$filter = new FilterChain();

// Вставляем фильтры в цепочку.
$filter->setOptions([
    'filters'=>[
        [
            'name'=>'StringTrim',
            'options'=>['charlist'=>"\r\n\t "],
            'priority'=>FilterChain::DEFAULT_PRIORITY
        ],
        [
            'name'=>'StripTags',
            'options'=>['tagsallowed'=>['p']],
            'priority'=>FilterChain::DEFAULT_PRIORITY
        ],
        [
            'name'=>'StripNewlines',
            'priority'=>FilterChain::DEFAULT_PRIORITY
        ]
    ]
]);

// Выполняем все фильтры в цепи.
$filteredValue = $filter->filter("  name@example.com<html>\n ");

// Ожидаемый вывод - 'name@example.com'.
~~~

В этом фрагменте первым делом мы инстанцируем фильтр `FilterChain` с помощью оператора `new` (строка 5).
В строке 8 мы задаем конструкцию цепочки фильтров методом `setOptions()`.

Этот метод принимает описание в виде массива, подобно методу `add()` класса `InputFilter()`.
Массив имеет ключ "filters", где вы можете зарегистрировать фильтры, которые хотите присоединить к цепи.
Для каждого добавленного фильтра нужно предоставить следующие подключи:

  * "name" - полностью определенное имя фильтра (например, `StringTrim::class`) или его псевдоним (например, "StringTrim");
  * "options"  - массив опций, передаваемых фильтру; и
  * "priority" - опциональный ключ, определяющий приоритет фильтра в цепи. Фильтры с более высоким
    приоритетом используются первыми. Значением по умолчанию для приоритета является `DEFAULT_PRIORITY`.

Наконец, в строке 28 мы вызываем метод `filter()`, который проходит по цепи и передает фильтруемое
значение каждому фильтру по очереди.

### Пользовательская фильтрация с помощью фильтра Callback

Стандартные фильтры предназначены для использования в часто встречающихся ситуациях. Например, вам
часто может понадобиться убрать пробелы из начала и конца строки или преобразовать ее в нижний регистр.
Однако, иногда могут возникнуть случаи, когда вы не можете использовать стандартный фильтр. В таких
ситуациях удобно пользоваться фильтром `Callback`.

Фильтр `Callback` разработан как обертка для вашего собственного алгоритма фильтрации. Это может быть
полезно, например, когда вам не подходят стандартные фильтры и к данным необходимо применить свой алгоритм 
фильтрации.

I> Пользовательский алгоритм фильтрации реализуется как функция обратного вызова или метод класса обратного вызова.
I> *Механизм обратного вызова* (callback) - это функция или public-метод класса, вызываемый фильтром `Callback`, принимающий
I> значение, которое нужно отфильтровать, и (опционально) аргумент(ы), определяемый(-е) пользователем.

Public-методы, предоставляемые фильтром `Callback` перечислены в таблице 8.17.

{title="Table 8.17. Public-методы фильтра Callback"}
|--------------------------------|---------------------------------------------------------------|
| *Имя класса*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Выполняет функцию обратного вызова в качестве фильтра.        |
|--------------------------------|---------------------------------------------------------------|
| `setCallback($callback)`       | Задает новый механизм обратного вызова для данного фильтра.   |
|--------------------------------|---------------------------------------------------------------|
| `getCallback()`                | Возвращает установленный для фильтра механизм обратного вызова. |
|--------------------------------|---------------------------------------------------------------|
| `setCallbackParams($params)`   | Задает параметры для механизма обратного вызова.              |
|--------------------------------|---------------------------------------------------------------|
| `getCallbackParams()`          | Получает параметры для механизма обратного вызова.            |
|--------------------------------|---------------------------------------------------------------|

Как видите из таблицы, фильтр `Callback` предоставляет методы `setCallback()` и `setCallbackParams()`,
которые можно использовать для задания функции обратного вызова (или метода класса обратного вызова)
и, возможно, передать ей один или несколько параметров.

#### Пример

Чтобы продемонстрировать использование фильтра `Callback`, присоединим поле номера телефона
к нашему классу модели формы обратной связи (`ContactForm`) и добавим к нему пользовательский фильтр.

Международный телефонный номер обычно выглядит как "1 (808) 456-7890". Он содержит код страны,
за которым следует код области из трех цифр, заключенных в скобки. Оставшаяся часть номера состоит из 
семизначного кода абонента, разделенного на две группы символом тире. Код страны, код области и код 
абонента разделены пробелами. В дальнейшем мы будем называть этот телефонный формат "международным" форматом.

Международный телефонный формат необходим для совершения звонков между странами (или областями). 
Если звонки делаются внутри одной и той же области, номер телефона может выглядеть как просто "456-7890" 
(код страны и код области просто опускаются). Такой формат мы будем называть "локальным" телефонным форматом.

Чтобы сделать наш фильтр как можно более универсальным, предположим, что пользователю необходимо ввести
номер в международном формате в одни формы и в локальном формате в другие.
Так как некоторые посетители сайта могут ввести свой телефонный номер в формате, отличном от требуемого,
мы хотим применить фильтр, который будет "нормализовывать" для нас номер.

Чтобы сделать "нормализацию" номера, фильтр:

 1. Уберет все нечисловые символы из входного значения.
 2. Дополнит значение цифрами до необходимой длины, если цифр слишком мало.
 3. Добавит скобки, пробелы и тире (при использовании международного формата); 
    или просто тире (при использовании локального формата).

Так как ZF3 не предоставляет стандартных фильтров для выполнения подобной операции фильтрации номера,
мы используем фильтр-обертку `Callback`. Для этого мы внесем следующие изменения в код нашего класса
`ContactForm`:
	
{line-numbers=on, lang=php}
~~~
<?php
// ...
class ContactForm extends Form
{
  // ...
  protected function addElements() 
  {
    // ...            
        
    // Добавляем поле "phone"
    $this->add([
        'type'  => 'text',
        'name' => 'phone',
        'attributes' => [                
           'id' => 'phone'
        ],
        'options' => [
           'label' => 'Your Phone',
        ],
     ]);
  }
    
  private function addInputFilter() 
  {
    // ...    
    $inputFilter->add([
        'name'     => 'phone',
        'required' => true,
        'filters'  => [                    
          [
            'name' => 'Callback',
            'options' => [
              'callback' => [$this, 'filterPhone'],
              'callbackParams' => [
                'format' => 'intl'
              ]
            ]                        
          ],
        ],                                
      ]);
  }
    
  // Пользовательский фильтр для номера телефона.
  public function filterPhone($value, $format) 
  {
    if(!is_scalar($value)) {
      // Возвращаем нескалярное значение нефильтрованным.
      return $value;
    }
            
    $value = (string)$value;
        
    if(strlen($value)==0) {
      // Возвращаем пустое значение нефильтрованным.
      return $value;
    }
        
    // Сначала удаляем все нечисловые символы.
    $digits = preg_replace('#[^0-9]#', '', $value);
        
    if($format == 'intl') {            
      // Дополняем нулями, если число цифр некорректно.
      $digits = str_pad($digits, 11, "0", STR_PAD_LEFT);

      // Добавляем скобки, пробелы и тире.
      $phoneNumber = substr($digits, 0, 1) . ' ('.
                     substr($digits, 1, 3) . ') ' .
                     substr($digits, 4, 3) . '-'. 
                     substr($digits, 7, 4);
    } else { // 'local'
      // Дополняем нулями, если число цифр некорректно.
      $digits = str_pad($digits, 7, "0", STR_PAD_LEFT);

      // Добавляем тире.
      $phoneNumber = substr($digits, 0, 3) . '-'. substr($digits, 3, 4);
    }
        
    return $phoneNumber;               
  }
}
~~~
 
В строках 11-20 вышеприведенного фрагмента мы добавляем поле "phone" к модели формы `ContactForm`. Это
поле является обычным текстовым полем ввода, и у нас уже был опыт работы с такими полями.

Затем, в строках 26-40 мы добавляем правило валидации для поля "phone" нашей формы. Под ключом
"filters" (строка 29) мы регистрируем фильтр `Callback` (в данном случае мы используем псевдоним `Callback`,
но вы можете вместо этого воспользоваться полностью определенным именем класса `Callback::class`).
 
Фильтр принимает две опции: "callback" и "callback_params". Опция "callback" - это массив, состоящий из
двух элементов, которые представляют соответственно класс и метод, который нужно вызвать. В этом примере,
механизмом обратного вызова является метод `filterPhone()` класса `ContactForm`. Параметр "format" передается
методу обратного вызова с помощью опции "callbackParams (строка 34).

В строках 44-79 мы определяем метод обратного вызова `filterPhone()`, принимающий два аргумента:
`$value` - номер телефона, который нужно отфильтровать и `$format` - желаемый формат номера.
Параметр `$format` может быть либо `local` (для локального формата), либо `intl` (для международного).

В методе обратного действия `filterPhone()` мы делаем следующее:

  * Сперва, в строке 46 мы проверяем, что параметр `$value` является скалярным значением, а не массивом. Если
    значение не скалярное, мы возвращаем его без изменений.
  
  * В строке 53 мы проверяем длины входного значения. Если пользователь ввел пустой номер телефона, мы ничего не
    делаем; мы просто возвращаем его как есть.
  
  * Затем мы удаляем все нецифровые символы (строка 59).
  
  * Если номер слишком короткий, мы дополняем его нулями.
  
  * Добавляем скобки, тире и пробелы для международных телефонных номеров;
    либо же просто тире для локальных телефонных номеров.

  * Наконец, мы возвращаем получившийся номер телефона.
  
Чтобы посмотреть, как работает этот фильтр, можете открыть URL "http://localhost/contactus" в своем браузере.
Если вы введете какой-либо номер телефона в некорректном формате, фильтр исправит номер и преобразует его
в желаемый формат.
	
## Написание своего собственного фильтра

Альтернативой использования фильтра `Callback` является написание своего собственного класса фильтра,
реализующего интерфейс `FilterInterface`. Фильтр затем можно будет использовать в формах вашего веб-приложения
(или, при желании, вне форм).

Чтобы продемонстрировать создание своего фильтра, мы напишем класс `PhoneFilter`, инкаспулирующий
алгоритм фильтрации номера, который мы использовали в примере фильтра `Callback`.

I> Как вы возможно помните, базовым классом для всех стандартных фильтров является класс `AbstractFilter`.
I> По аналогии мы также будем наследовать наш фильтр `PhoneFilter` от этого базового класса.

Мы планируем иметь следующие методы в классе фильтра `PhoneFilter` (см. таблицу 8.18):

{title="Таблица 8.18. Public-методы PhoneFilter"}
|--------------------------------|---------------------------------------------------------------|
| *Имя метода*                   | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `__construct($options)`        | Конструктор - принимает опциональный аргумент `$options`, который нужен для того, чтобы сразу задать опции фильтра. |
|--------------------------------|---------------------------------------------------------------|
| `setFormat($format)`           | Задает опцию формата номера.                                  |
|--------------------------------|---------------------------------------------------------------|
| `getFormat()`                  | Возвращает опцию формата номера.                              |
|--------------------------------|---------------------------------------------------------------|
| `filter($value)`               | Запускает фильтр.                                             |
|--------------------------------|---------------------------------------------------------------|

Сперва создайте файл *PhoneFilter.php* в каталоге *Filter* под 
корневым каталогом модуля [^сервис_фильтра_номера]. Поместите в этот файл
следующий код:

[^сервис_фильтра_номера]: Класс `PhoneFilter` можно считать моделью сервиса, так как его задачей является
       обработка данных, а не их хранение. Все пользовательские фильтры принято хранить под каталогом `Filter`.

{line-numbers=on, lang=php}
~~~
<?php
namespace Application\Filter;

use Zend\Filter\AbstractFilter;

// Этот класс фильтра предназначен для преобразования произвольного номера телефона в 
// локальный или международный формат.
class PhoneFilter extends AbstractFilter 
{    
  // Константы форматов номера.
  const PHONE_FORMAT_LOCAL = 'local'; // Local phone format 
  const PHONE_FORMAT_INTL  = 'intl';  // International phone format 
    
  // Доступные опции фильтра.
  protected $options = [
    'format' => self::PHONE_FORMAT_INTL
  ];
    
  // Конструктор.
  public function __construct($options = null) 
  {     
    // Задает опции фильтра (если они предоставлены).
    if(is_array($options)) {
            
      if(isset($options['format']))
        $this->setFormat($options['format']);
    }
  }
    
  // Задает формат номера.
  public function setFormat($format) 
  {        
    // Проверяет входной аргумент.
    if( $format!=self::PHONE_FORMAT_LOCAL && 
       $format!=self::PHONE_FORMAT_INTL ) {            
      throw new \Exception('Invalid format argument passed.');
    }
        
    $this->options['format'] = $format;
  }

  // Возвращает формат номера.
  public function getFormat() 
  {
    return $this->format;
  }  
	
  // Фильтрует телефонный номер.
  public function filter($value) 
  {                
    if(!is_scalar($value)) {
      // Возвращаем нескалярное значение неотфильтрованным.
      return $value;
    }
            
    $value = (string)$value;
        
    if(strlen($value)==0) {
      // Возвращаем пустое значение неотфильтрованным.
      return $value;
    }
        
    // Сперва удаляем все нецифровые символы.
    $digits = preg_replace('#[^0-9]#', '', $value);
        
    $format = $this->options['format'];
        
    if($format == self::PHONE_FORMAT_INTL) {            
      // Дополняем нулями, если число цифр некорректно.
      $digits = str_pad($digits, 11, "0", STR_PAD_LEFT);

      // Добавляем скобки, пробелы и тире.
      $phoneNumber = substr($digits, 0, 1) . ' (' . 
                     substr($digits, 1, 3) . ') ' .
                     substr($digits, 4, 3) . '-' . 
                     substr($digits, 7, 4);
    } else { // self::PHONE_FORMAT_LOCAL
      // Дополняем нулями, если число цифр некорректно
      $digits = str_pad($digits, 7, "0", STR_PAD_LEFT);

      // Добавляем тире.
      $phoneNumber = substr($digits, 0, 3) . '-'. substr($digits, 3, 4);
    }
        
    return $phoneNumber;                
  }    
}
~~~

Как видите из строки 2 класс фильтра содержится в пространстве имен `Application\Filter`.

В строке 8 мы определяем класс `PhoneFilter`. Мы наследуем наш фильтр от базового класса
`AbstractFilter` для повторного использования предоставляемой им функциональности. Строка 4
содержит псевдоним для класса AbstractFilter`.

В строках 11-12 мы для удобства определяем константы форматов номера (`PHONE_FORMAT_INTL` для 
международного формата и `PHONE_FORMAT_LOCAL` для локального). Эти константы - эквиваленты
строк "intl" и "local" соответственно.

В строках 15-17 мы определяем private-переменную `$options`, которая является массивом, имеющим
один единственный ключ под названием "format". Этот ключ будет содержать опцию формата номера для
нашего фильтра.

В строках 20-28 находится метод конструктора, который принимает один аргумент `$options`.
При создании фильтра вручную, этот параметр можно пропустить. Однако, когда фильтр создается
классом фабрики, фабрика будет передавать опции фильтра его конструктору через этот аргумент.

В строках 31-40 и 43-46 находятся методы `setFormat()` и `getFormat()`, позволяющие соответственно
задать и извлечь текущий формат номера.

В строках 49-86 находится метод `filter()`. Этот метод инкапсулирует алгоритм фильтрации телефонного 
номера. Он принимает параметр `$value`, преобразовывает его с учетом выбранного формата номера
и возвращает отформатированный номер телефона.

### Использование класса PhoneFilter

Как только класс фильтра `PhoneFilter` будет готов, вы легко можете начать его использовать в
форме обратной связи (или других формам) как показано ниже. Предполагается, что вы вызываете
следующий код внутри метода `ContactForm::addInputFilter()`:

{line-numbers=off, lang=php}
~~~
$inputFilter->add([
      'name'     => 'phone',
      'required' => true,                
      'filters'  => [                    				
        [
          'name' => PhoneFilter::class,
          'options' => [
            'format' => PhoneFilter::PHONE_FORMAT_INTL
          ]
        ],
        // ...
      ],                
      // ...
    ]);
~~~

Вы можете посмотреть, как работает фильтр `PhoneFilter` в примере *Form Demo* - приложении, которое идет
вместе с этой книгой. Откройте страницу "http://localhost/contactus" в своем браузере. Если вы введете
какой-либо телефонный номер в некорректном формате, фильтр исправит номер.

Если хотите, можете использовать `PhoneFilter` вне форм, как показано во фрагменте кода ниже:

{line-numbers=off, lang=php}
~~~
<?php 
use Application\Filter\PhoneFilter;

// Создаем фильтр PhoneFilter.
$filter = new PhoneFilter();

// Настраиваем фильтр.
$filter->setFormat(PhoneFilter::PHONE_FORMAT_INTL);

// Фильтруем строку.
$filteredValue = $filter->filter('12345678901');

// Ожидаемый вывод фильтра - '1 (234) 567-8901'.
~~~

## Выводы

Фильтры предназначены для приема входных данных, их обработки, а затем создания выходных данных.
Zend Framework 3 предоставляет множество стандартных фильтров, которые можно использовать для 
создания правил фильтрации ваших форм (или, если хотите, чтобы отфильтровать произвольные данные вне форм).

Стандартные фильтры можно приблизительно разделить на следующие группы:

 * Фильтры для приведения входных данных к определенному типу;
 * фильтры, выполняющие манипуляции с путем к файлу;
 * фильтры, осуществляющие сжатие и шифрование входных данных;
 * фильтры, управляющие строковыми данными; и
 * фильтры-заместители - обертки для других фильтров.

Если стандартные фильтры не подходят, вы можете создать свой класс фильтра.
В этой главе мы привели пример того, как написать собственный класс `PhoneFilter`,
способный фильтровать телефонные номера.
