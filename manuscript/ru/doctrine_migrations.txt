# Миграции баз данных {#migrations}

При разработке веб-сайта вы постоянно модифицируете схему вашей базы данных: добавляете одни
таблицы, изменяете другие, а третьи, ненужные вам, удаляете. Управление схемой БД может стать
очень сложной задачей из-за необходимости ее поддержки на сервере разработки, сервере тестирования
и рабочем сервере. Однако, эту задачу можно значительно упростить с помощью *миграций*.

Миграция - это своего рода атомарное изменение состояния схемы БД. Можно как применить
миграцию, чтобы обновить схему до ее нового состояния, так и убрать ее, вернувшись к
предыдущему состоянию схемы. Новые миграции создаются в процессе разработки веб-сайта.
Вы можете иметь столько миграций, сколько необходимо. Они также образовывают историю
изменений схемы базы данных - удобное средство, благодаря которому вы всегда знаете,
когда и с какой целью изменили схему.

## Установка компонента Doctrine\Migrations

Doctrine предоставляет специальный компонент `Doctrine\Migrations`, который вы можете 
использовать для реализации миграций на своем сайте.
Для установки этого компонента наберите следующую команду:

~~~
php composer.phar require doctrine/migrations
~~~

Эта команда загрузит и установит файлы компонента в каталог `vendor` и изменит
файл `composer.json` следующим образом:

~~~
{
    ...
    "require": {
        ...
        "doctrine/migrations": "^1.4",
        ...
    },
    ...
}
~~~

## Настройка миграций

Перед тем, как начать использовать миграции, нужно составить конфигурацию, описывающую,
какие подключения к БД использовать, в какой таблице хранить историю миграций, где
хранить классы миграций и др. Для этого добавьте следующий код в файл `config/autoload/global.php`:


{line-numbers=on,lang=php}
~~~
<?php
return [    
    'doctrine' => [        
        // настройка миграций
        'migrations_configuration' => [
            'orm_default' => [
                'directory' => 'data/Migrations',
                'name'      => 'Doctrine Database Migrations',
                'namespace' => 'Migrations',
                'table'     => 'migrations',
            ],
        ],
    ],
    // ...
];
~~~

Как видите, под ключом `doctrine` находится подключ `migrations_configuration` (строка 5). Под `migrations_configuration`
мы указываем следующую настройку миграций:

  * В строке 6 мы указываем в качестве имени менеджера сущностей стандартное (`orm_default`). 

  * В строке 7 мы сообщаем Doctrine, что хотим хранить миграции под каталогом `APP_DIR/data/Migrations`.
  
  * В строке 8 мы указываем удобное имя для наших миграций.
  
  * В строке 9 мы сообщаем Doctrine, что хотим содержать классы миграций в пространстве имен `Migrations`.
    Вы можете указать пространство имен на ваш выбор.

  * В строке 10 мы сообщаем Doctrine, что хотим хранить историю миграций в таблице базы данных 
    `migrations`. Doctrine автоматически создаст эту таблицу и будет ей управлять.  
  
## Создание миграций

Миграция - это набор изменений, либо обновляющий схему, либо возвращающий ее к предыдущему состоянию.
Пустая миграция генерируется следующими командами:

~~~
cd APP_DIR
./vendor/bin/doctrine-module migrations:generate
~~~

Эти команды назначают каталог приложения текущим рабочим каталогом и затем выполняют
консольную команду `migrations:generate`.

I> `DoctrineModule` и `DoctrineORMModule` предоставляют несколько консольных команд, которые можно использовать
I> для различных задач, связанных с поддержкой базы данных (например, генерации или выполнения миграций). Список доступных
I> команд можно посмотреть с помощью команды `list`:
I>
I> `./vendor/bin/doctrine-module list`

После запуска команды `migrations:generate` созданную миграцию можно будет найти под каталогом `APP_DIR/data/Migrations`.
Имя файла миграции имеет вид `VersionYYYYMMDDHHIISS.php`, где `YYYY` - текущий год, `MM` - текущий месяц, `DD` - текущий день,
а `HH`, `II` и `SS` - соответственно текущие час, минута и секунда.

Если вы откроете созданный файл, то увидите следующее содержимое:

{line-numbers=off,lang=php}
~~~
<?php

namespace Migrations;

use Doctrine\DBAL\Migrations\AbstractMigration;
use Doctrine\DBAL\Schema\Schema;

/**
 * Автоматически сгенерированная миграция: измените под ваши нужды!
 */
class Version20160901114333 extends AbstractMigration
{
    /**
     * @param Schema $schema
     */
    public function up(Schema $schema)
    {
        // эта миграция up() сгенерирована автоматически, пожалуйста, измените ее под свои нужды

    }

    /**
     * @param Schema $schema
     */
    public function down(Schema $schema)
    {
        // эта миграция down() сгенерирована автоматически, пожалуйста, измените ее под свои нужды

    }
}
~~~

T> Если вы не видите созданную миграцию в NetBeans, откройте меню *Source* и выберите
T> пункт меню *Scan for external changes*.

Как видите из фрагмента кода выше, миграция - это обычный PHP-класс, наследуемый от базового класса `Doctrine\DBAL\Migrations\AbstractMigration`.
У каждой миграции должно быть *по крайней мере* два метода: `up()` and `down()`. Метод `up()` обновляет схему до нового состояния,
а метод `down()` возвращает к предыдущему. Оба этих метода принимают один аргумент типа `Doctrine\DBAL\Schema\Schema`, который можно
использовать для фактического изменения схемы базы данных.

T> Класс `Schema` является частью компонента `Doctrine\DBAL`. За дополнительной информацией о предоставляемых им методах
T> обратитесь к документации DBAL. Либо, что даже лучше, посмотрите на код внутри каталога `vendor/doctrine/dbal`.

Класс миграции может иметь следующие (переопределенные) методы (таблица 13.1):

{title="Таблица 13.1. Методы, которые может содержать класс миграции"}
|--------------------------------|---------------------------------------------------------------|
| *Метод*                        | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `isTransactional()`            | Если эта функция возвращает true (по умолчанию), вся миграция будет выполнена как одна транзакция; |
|                                | иначе, каждый из SQL-запросов миграции будет выполнен отдельно. |
|--------------------------------|---------------------------------------------------------------|
| `getDescription()`             | Этот метод должен возвращать строку, описывающую миграцию (с какой целью сделано это изменение схемы) |
|--------------------------------|---------------------------------------------------------------|
| `preUp(Schema $schema)`        | Этот метод будет выполнен перед обновлением схемы.            |
|--------------------------------|---------------------------------------------------------------|
| `postUp(Schema $schema)`       | Этот метод будет выполнен после обновления схемы.             |
|--------------------------------|---------------------------------------------------------------|
| `preDown(Schema $schema)`      | Этот метод будет выполнен перед возвратом схемы к предыдущему состоянию. |
|--------------------------------|---------------------------------------------------------------|
| `postDown(Schema $schema)`     | Этот метод будет выполнен после возврата схемы к предыдущему состоянию. |
|--------------------------------|---------------------------------------------------------------|
 
Базовый класс `AbstractMigration` также предоставляет следующие полезные методы (таблица 13.2):

{title="Table 13.2. Methods provided by the base migration class"}
|--------------------------------|---------------------------------------------------------------|
| *Метод*                        | *Описание*                                                    |
|--------------------------------|---------------------------------------------------------------|
| `addSql($sql, array $params = [], array $types = [])` | Этот метод позволяет выполнить произвольный SQL-запрос. |
|--------------------------------|---------------------------------------------------------------|
| `write($message)`              | Этот метод помощника выводит сообщение (поясняющее или об отладке) на экран. |
|--------------------------------|---------------------------------------------------------------|
| `throwIrreversibleMigrationException($message = null)` | Этот метод помощника, как правило, вызывается внутри метода `down()`, чтобы сообщить, что миграцию нельзя отменить. |
|--------------------------------|---------------------------------------------------------------|

Как видите из таблицы 13.2, вы также можете изменить схему, вызвав метод `addSql()`. Этот метод можно
использовать для создания таблицы, ее обновления или удаления. Кроме того, его можно использовать, например,
для вставки каких-либо данных в таблицы (однако, вставка данных не является изменением схемы).

I> Миграции Doctrine предназначены для изменений схемы, а не для добавления данных в базу. Впрочем,
I> вставка начальных данных в некоторых случаях весьма полезна. 

Теперь, когда вы знаете, как создать миграцию, давайте создадим пару миграций для нашего приложения *Blog*.

### Создание начальной миграции

Начальная миграция будет первой, которую мы создадим. Она будет применена к схеме пустой базы данных
и создаст четыре таблицы: `post`, `comment`, `tag` и `post_tag`.

Измените созданный нами в предыдущем разделе класс миграции, чтобы он выглядел, как показано ниже:

{line-numbers=off,lang=php}
~~~
<?php

namespace Migrations;

use Doctrine\DBAL\Migrations\AbstractMigration;
use Doctrine\DBAL\Schema\Schema;

/**
 * Класс миграции. Он либо обновляет схему БД (приводит к новому состоянию), либо
 * возвращает ее к предыдущему состоянию.
 */
class Version20160901114333 extends AbstractMigration
{
    /**
     * Возвращает описание этой миграции.
     */
    public function getDescription()
    {
        $description = 'This is the initial migration which creates blog tables.';
        return $description;
    }
    
    /**
     * @param Schema $schema
     */
    public function up(Schema $schema)
    {
        // Создаем таблицу 'post'
        $table = $schema->createTable('post');
        $table->addColumn('id', 'integer', ['autoincrement'=>true]);        
        $table->addColumn('title', 'text', ['notnull'=>true]);
        $table->addColumn('content', 'text', ['notnull'=>true]);
        $table->addColumn('status', 'integer', ['notnull'=>true]);
        $table->addColumn('date_created', 'datetime', ['notnull'=>true]);
        $table->setPrimaryKey(['id']);
        $table->addOption('engine' , 'InnoDB');
        
        // Создаем таблицу 'comment'
        $table = $schema->createTable('comment');
        $table->addColumn('id', 'integer', ['autoincrement'=>true]); 
        $table->addColumn('post_id', 'integer', ['notnull'=>true]);
        $table->addColumn('content', 'text', ['notnull'=>true]);
        $table->addColumn('author', 'string', ['notnull'=>true, 'lenght'=>128]);
        $table->addColumn('date_created', 'datetime', ['notnull'=>true]);
        $table->setPrimaryKey(['id']);
        $table->addOption('engine' , 'InnoDB');
        
        // Создаем таблицу 'tag'
        $table = $schema->createTable('tag');
        $table->addColumn('id', 'integer', ['autoincrement'=>true]); 
        $table->addColumn('name', 'string', ['notnull'=>true, 'lenght'=>128]);
        $table->setPrimaryKey(['id']);
        $table->addOption('engine' , 'InnoDB');
        
        // Создаем таблицу 'post_tag'
        $table = $schema->createTable('post_tag');
        $table->addColumn('id', 'integer', ['autoincrement'=>true]); 
        $table->addColumn('post_id', 'integer', ['notnull'=>true]);
        $table->addColumn('tag_id', 'integer', ['notnull'=>true]);
        $table->setPrimaryKey(['id']);
        $table->addOption('engine' , 'InnoDB');       
    }

    /**
     * @param Schema $schema
     */
    public function down(Schema $schema)
    {
        $schema->dropTable('post_tag');
        $schema->dropTable('tag');
        $schema->dropTable('comment');
        $schema->dropTable('post');
    }
}
~~~

Во фрагменте кода выше находятся три метода:

  * метод `getDescription()`, предоставляющий описание миграции.
  * метод `up()` обновляет схему, добавляя новые таблицы.
  * метод `down()` удаляет таблицы, тем самым возвращая схему к ее предыдущему состоянию.

### Добавление еще одной миграции

Теперь, предположим, мы решили повысить производительность нашей базы данных, добавив к таблицам индексы.

T> Если вы хотите более детально узнать о индексах баз данных и о том, почему они так полезны, можете обратиться 
T> к отличному руководству [Use the Index, Luke](http://use-the-index-luke.com/).

Кроме того, мы можем повысить целостность данных, добавив внешние ключи. Для этого нужно добавить еще одну миграцию.
Сгенерируйте пустую миграцию с помощью консольной команды `migrations:generate`. Измените код следующим образом:

{line-numbers=off,lang=php}
~~~
<?php

namespace Migrations;

use Doctrine\DBAL\Migrations\AbstractMigration;
use Doctrine\DBAL\Schema\Schema;

/**
 * Класс миграции. Он либо обновляет схему БД (приводит к новому состоянию), либо
 * возвращает ее к предыдущему состоянию.
 */
class Version20160901114938 extends AbstractMigration
{
    /**
     * Возвращает описание этой миграции.
     */
    public function getDescription()
    {
        $description = 'This migration adds indexes and foreign key constraints.';
        return $description;
    }
    
    /**
     * @param Schema $schema
     */
    public function up(Schema $schema)
    {
        // Добавляем индекс к таблице post
        $table = $schema->getTable('post');
        $table->addIndex(['date_created'], 'date_created_index');
        
        // Добавляем индекс и внешний ключ к таблице comment
        $table = $schema->getTable('comment');
        $table->addIndex(['post_id'], 'post_id_index');
        $table->addForeignKeyConstraint('post', ['post_id'], ['id'], [], 'comment_post_id_fk');
        
        // Добавляем индексы и внешние ключи к таблице post_tag table
        $table = $schema->getTable('post_tag');
        $table->addIndex(['post_id'], 'post_id_index');
        $table->addIndex(['tag_id'], 'tag_id_index');
        $table->addForeignKeyConstraint('post', ['post_id'], ['id'], [], 'post_tag_post_id_fk');
        $table->addForeignKeyConstraint('tag', ['tag_id'], ['id'], [], 'post_tag_tag_id_fk');
    }

    /**
     * @param Schema $schema
     */
    public function down(Schema $schema)
    {
        $table = $schema->getTable('post_tag');
        $table->removeForeignKey('post_tag_post_id_fk');
        $table->removeForeignKey('post_tag_tag_id_fk');
        $table->dropIndex('post_id_index');
        $table->dropIndex('tag_id_index'); 
        
        $table = $schema->getTable('comment');
        $table->dropIndex('post_id_index'); 
        $table->removeForeignKey('comment_post_id_fk');
        
        $table = $schema->getTable('post');
        $table->dropIndex('date_created_index');       
    }
}
~~~

T> Созданные нами миграции вы можете найти в примере *Blog*, который идет вместе с этой книгой.

## Выполнение миграций

Как только классы миграций будут готовы, вы сможете применить миграции к базе данных. Чтобы это сделать,
используйте консольную команду `migrations:migrate` как показано ниже:

~~~
./vendor/bin/doctrine-module migrations:migrate
~~~

Данная команда по очереди применяет все доступные миграции. Она записывает ID применяемых миграций 
в таблицу БД `migrations`. После этого таблица `migrations` будет выглядеть следующим образом:

~~~
mysql> select * from migrations;
+----------------+
| version        |
+----------------+
| 20160901114333 |
| 20160901114938 |
+----------------+
2 rows in set (0.00 sec)
~~~

Если вы хотите обновить или восстановить базу данных до определенной версии, укажите ID миграции в качестве
аргумента команды `migrations:migrate` таким образом:

~~~
./vendor/bin/doctrine-module migrations:migrate 20160901114333
~~~

T> В качестве ID версий также можно использовать псевдонимы 'prev', 'next' и 'first', которые соответственно
T> приводят БД к предыдущему состоянию, следующему состоянию или состоянию до первой миграции (т.е., к пустой БД). 

Таким образом, используя миграции, можно легко перемещаться по их истории и вносить необходимые
изменения в схему базы данных. Будьте осторожнее с миграциями: так как они могут удалить некоторые ваши данные,
применять их следует с умом.

## Выводы

В этой главе мы узнали о миграциях баз данных. Библиотека Doctrine предоставляет компонент `Doctrine\Migrations`,
позволяющий реализовывать и применять миграции.

Миграция - это своего рода набор изменений, который можно применить к схеме БД. Миграцию можно как применить, чтобы 
обновить схему до нового состояния, так и убрать, чтобы вернуть схему к ее предыдущему состоянию.

Миграции весьма полезны, так как они позволяют хранить историю изменений схемы и применять изменения
стандартным способом. С помощью миграций можно легко поддерживать схему на любой машине для разработки,
а также на сервере тестирования, сервере для "обкатки" (staging server) и рабочем сервере.
