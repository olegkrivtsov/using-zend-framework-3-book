{mainmatter}

# Introducción a Zend Framework 3 {#intro}

En este capítulo aprenderemos sobre Zend Framework 3, sus principios y sus
componentes.

## ¿Qué es Zend Framework 3?

PHP es un lenguaje de desarrollo web muy popular. Sin embargo escribir sitios web
en PHP puro es difícil. Si escribimos una aplicación web en PHP puro tendremos que
organizar el código de alguna manera, capturar y validar los datos que ingresa
el usuario, implementar la autenticación de usuarios y el control de acceso,
administrar bases de datos, probar el código, etc. A medida que nuestro sitio
crece en tamaño se vuelve más y más difícil escribir código de una manera
consistente. Cada desarrollador de nuestro equipo aplica su estilo y patrones
favoritos. El código comienza a complicarse demasiado, ser lento y difícil de
mantener. Mezclamos todo nuestro código en un solo y gigante script sin
separación de conceptos. Tenemos que reinventar la rueda muchas veces causando
problemas de seguridad. Y mucho más importante, luego cuando nos ponemos a
desarrollar un nuevo sitio web vemos que una parte considerable del código
que ya hemos escrito para el antiguo sitio web se puede usar nuevamente con
pequeñas modificaciones. Es decir, el código podría separarse en una biblioteca.
Pero, esta es la manera como funciona un framework.

I> Un framework es un tipo de biblioteca, una pieza de software (también escrita
I> en PHP) que provee a los desarrolladores web con código base y una manera
I> consistente y estandarizada de crear aplicaciones web.

Zend Framework 3 es un framework de PHP disponible como Software Libre y Código
Abierto. Su desarrollo esta guiado y patrocinado por Zend Technologies que es
además conocido como el mantenedor del lenguaje de programación PHP. La primera
versión (Zend Framework 1) se lanzó en 2007; Zend Framework 2, la segunda
versión del software, se lanzó en septiembre de 2012. Zend Framework 3 (ZF3)
se lanzó en junio de 2016.

Zend Framework 3 provee las siguientes capacidades:

* Permite desarrollar un sitio web mucho más rápido que cuando lo escribimos
  en PHP puro. ZF3 provee muchos componentes que se pueden usar como código
  base para nuestro sitio web.

* Es más fácil cooperar con los otros miembros de nuestro equipo de desarrollo.
  El patrón Modelo-Vista-Controlador que usa ZF3 permite separar la lógica del
  negocio y la capa de presentación de nuestro sitio web haciendo su estructura
  consistente y fácil de mantener.

* Permite escalar el sitio web con el concepto de módulos. ZF3 usa el concepto
  de *módulos* que permite separar el sitio en partes que se puedan desacoplar
  permitiendo reusar los modelos, las vistas, los controladores y archivos
  estáticos de un sitio web a otro.

* Permite acceder a la base de datos de una manera orientada a objetos en
  lugar de interactuar directamente con la base de datos usando consultas SQL.
  Podemos usar el mapeo objeto-ralacional de Doctrine (ORM) para administrar
  la estructura y las relaciones entre nuestros datos. Con Doctrine podemos
  asociar nuestras tablas de base de datos a clases PHP (llamadas *entidades*)
  y cada fila de la tabla se asocia con una instancia de clase a la que está
  asociada la tabla. Doctrine permite abstraernos de la base de datos y
  hacer el código más fácil de entender.

* Permite escribir sitios web seguros con ayuda de los componentes que ZF3
  provee, como filtros y validadores para los datos ingresados en los formularios,
  escapar la salida HTML, algoritmos criptográficos, detectores
  de humanos (Captcha) y falsificación de petición en sitios cruzados (CSRF).

## Una Ejemplo de un Sitio Web con PHP

Para demostrar cuán difícil es escribir un sitio web *sin* un framework
de PHP escribiremos una aplicación web muy simple que consiste en tres páginas
HTML: *Home*, *Login* y *Logout*. Para este ejemplo, no usaremos ningún
framework e intentaremos usar solo PHP "puro".

I> No nos confundamos, escribir un sitio web con un framework de PHP puede
I> ser difícil pero con un framework lo haremos de una manera segura y
I> consistente.

### Página Principal

I> Cuando escribimos un sitio web con PHP colocamos el código dentro de un
I> archivo con extensión `.php`. Este archivo se llama *script* de PHP.

Primero vamos a implementar la página *Home* para nuestro sitio web. Para
hacer esto creamos el archivo `index.php` en la carpeta raíz de documentos de
Apache y colocamos el siguiente código dentro de él.

T> Para entender el código de abajo necesitamos tener alguna experiencia
T> con PHP. Si no tenemos experiencia con PHP sería bueno revisar algún
T> tutorial de PHP como [w3schools.com](http://www.w3schools.com/php/).

{line-numbers=off,lang="php"}
~~~
<?php
// index.php
session_start();

// If user is logged in, retrieve identity from session.
$identity = null;
if (isset($_SESSION['identity'])) {
    $identity = $_SESSION['identity'];
}
?>

<!DOCTYPE html>
<html>
    <head>
        <title>Home page</title>
    </head>
    <body>
        <h1>Home</h1>
        <?php if ($identity==null): ?>
        <a href="login.php">Sign in</a>
        <?php else: ?>
        <strong>Welcome, <?= $identity ?></strong> <a href="logout.php">Sign out</a>
        <?php endif; ?>

        <p>
            This is a simple website to demonstrate the advantages of a PHP framework
            and disadvantages of "pure" PHP.
        </p>
    </body>
</html>
~~~

Si escribimos *http://localhost/index.php* en nuestro navegador web (como
Firefox o Google Chrome) deberíamos ver una página como la siguiente:

![Una Página Home Simple](../en/images/intro/simple_home_page.png)

### Página de Inicio de Sesión

Ahora vamos a implementar la página de *Login*. Esta página podría tener un
formulario con los campos *E-mail* y *Contraseña*. Una vez que el usuario
envía el formulario y pasa el proceso de autenticación su identidad se
guarda en la variables sesión de PHP. El script podría tener el siguiente
aspecto:

{line-numbers=off,lang="php"}
~~~
<?php
// login.php
session_start();

// If user is logged in, redirect him to index.php
if (isset($_SESSION['identity'])) {
    header('Location: index.php');
    exit;
}

// Check if form is submitted.
$submitted = false;
if ($_SERVER['REQUEST_METHOD']=='POST') {

    $submitted = true;

    // Extract form data.
    $email = $_POST['email'];
    $password = $_POST['password'];

    // Authenticate user.
    $authenticated = false;
    if ($email=='admin@example.com' && $password=='Secur1ty') {
        $authenticated = true;

        // Save identity to session.
        $_SESSION['identity'] = $email;

        // Redirect the user to index.php.
        header('Location: index.php');
        exit;
    }
}
?>

<!DOCTYPE html>
<html>
    <head>
        <title>Login page</title>
    </head>
    <body>
        <h1>Sign in</h1>
        <?php if ($submitted && !$authenticated): ?>
            <div class="alert">
                Invalid credentials.
            </div>
        <?php endif; ?>
        <form name="login-form" action="/login.php" method="POST">
            <label for="email">E-mail</label>
            <input type="text" name="email">
            <br>
            <label for="password">Password</label>
            <input type="password" name="password">
            <br>
            <input type="submit" name="submit" value="Sign In">
        </form>
    </body>
</html>
~~~

Si abrimos la URL *http://localhost/login.php* en nuestro navegador deberíamos
ver algo como:

![Una Página Simple de Login](../en/images/intro/simple_login_page.png)

T> Para iniciar sesión usamos el E-mail y contraseña `admin@example.com`
T> y `Secur1ty` respectivamente.

### Página para Cerrar Sesión

Y finalmente vamos a implementar la página *Logout* que limpiará la identidad
del usuario:

{line-numbers=off,lang="php"}
~~~
<?php
// logout.php
session_start();

unset($_SESSION['identity']);
header('Location: index.php');
exit;
~~~

T> El código completo de este sitio web se puede encontrar en el ejemplo
T> [Pure PHP](https://github.com/olegkrivtsov/using-zf3-book-samples/tree/master/purephp)
T> que acompaña a este libro.

### Reviewing the Code

El script de arriba no solo es un ejemplo típico de una sitio web con PHP "puro",
además, es un ejemplo de como *no deberíamos* escribir nuestro sitio web
(incluso un sitio web simple). Pero, ¿Que hay de malo con esto?

1. Los scripts `index.php` y `login.php` tienden a mezclar todo el código en
   un solo archivo. No estamos aplicando separación de conceptos lo que hace
   a nuestro código mucho más complejo. Intuitivamente podemos entender que
   podría ser más conveniente separar el código responsable de la autenticación
   del usuario y el código responsable de la presentación (impresión del HTML).

2. Las direcciones URL de nuestras páginas web no se ven bien (por ejemplo,
   `http://localhost/index.php`). Nos gustaría esconder la extensión `.php`.
   Ademas, ¿que sucede cuando un usuario intenta visitar una página que no
   existe? En este caso nos gustaría redirigir al usuario a una página de
   error.

3. ¿Que sucede si nuestro sitio web crece en tamaño? ¿Como podríamos organizar
   el código? ¿un script PHP por cada página web? Y que si queremos reusar
   algunos de nuestros script PHP en otros sitios web sin cambios? Intuitivamente
   podríamos entender que podría ser útil organizar el código en algún tipo de
   *módulos* reusables.

4. Ambos scripts, `index.php` y `login.php`, contienen código HTML común. ¿Por qué
   copiar y pegar este código de presentación en cada script PHP? Nos
   gustaría reusar la misma plantilla maestra en todas o en la mayoría de las
   páginas.

5. El script `login.php` tiene problemas de seguridad, porque no implementamos
   ninguna validación para las variables POST. Igualmente las sesiones de PHP pueden
   ser objeto de cracking. Además, el script PHP `login.php` está dentro de la
   carpeta raíz de documentos de Apache lo que no es muy seguro (es mejor
   colocarlo en un lugar que no sea accesible para los usuarios web). Además, el
   `index.php` es inseguro porque no se filtra la salida PHP lo que lo hace
   vulnerable a ataques XSS.

6. Ninguno de estos scripts usa clases PHP. En teoría si se encapsulan
   funcionalidades dentro de clases el código estaría mejor estructurado y
   sería más fácil de mantener.

7. En estos scripts debemos escribir nuestra propia implementación de la
   autenticación y así de las otras funcionalidades. ¿Por qué reinventar la
   rueda y no usar una biblioteca bien diseñada para esto?

Los problemas de arriba se resuelven fácilmente cuando escribimos un sitio web
con un framework (como Zend Framework 3):

1. En ZF3 usamos el patrón de diseño *Modelo-Vista-Controlador* separando el
   código PHP en modelos (el código responsable de la autenticación debería ir
   aquí), vistas (el código responsable de la impresión del HTML debería ir
   aquí) y los controladores (el código responsable de recuperar las variables
   POST debería ir aquí).

2. El *enrutamiento* de ZF3 permite tener URL con un aspecto profesional, esto
   se consigue ocultando la extensión `.php`. Como las URLs se pueden parecer
   se definen mediante reglas estrictas. Si un usuario intenta ver una página
   que no existe es automáticamente redirecionado a la página de error
   estándar.

3. En ZF3 podemos usar el concepto de *módulo*. Este permite convenientemente
   separar nuestros modelos, vistas y controladores en unidades autónomas
   (módulos) y reusar con facilidad esta unidad en otro proyecto.

4. En ZF3 podemos definir una *maqueta* de plantilla de vista común y reusarla
   en todas o en la mayoría de las páginas web.

5. ZF3 nos provee de varias características de seguridad como filtros de
   de formulario y validadores, escapar la salida, validadores de sesión,
   algoritmos criptográficos, etc. En un sitio web con ZF3 solamente el `index.php`
   es accesible para los usuarios web, todos los otros script de PHP se
   almacenan fuera de la carpeta raíz de documentos de Apache.

6. En un sitio web con ZF3 colocamos el código dentro de clases dejándolo
   mejor organizado.

7. ZF3 nos provee de muchos componentes que podemos usar en nuestro sitio web:
   un componente de autenticación, un componente para trabajar con formularios,
   etc.

T> Ahora que tenemos una idea de las ventajas de usar Zend Framework 3 y lo que
T> él puede hacer por nosotros dedicaremos la siguiente sección a describir
T> ZF3 con más detalles.

## Licencia

Zend Framework está licenciado con la licencia *BSD-like* que nos permite usarlo
tanto en aplicaciones comerciales como libres. Incluso podemos modificar el
código de la biblioteca y publicarlo usando otro nombre. La única cosa que no
podemos hacer es remover la nota de *copyright* del código. Si usamos Zend
Framework 3 es recomendable que lo mencionemos en la documentación de nuestro
sitio o en la página *Acerca de*.

Abajo presentamos el texto de la licencia de Zend Framework 3.

{line-numbers=off,lang=text}
~~~
Copyright (c) 2005-2016, Zend Technologies USA, Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

	* Redistributions of source code must retain the above copyright
	  notice, this list of conditions and the following disclaimer.

	* Redistributions in binary form must reproduce the above copyright
	  notice, this list of conditions and the following disclaimer in
	  the documentation and/or other materials provided with the
	  distribution.

	* Neither the name of Zend Technologies USA, Inc. nor the names of
	  its contributors may be used to endorse or promote products
	  derived from this software without specific prior written
	  permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
~~~

## Soporte de Usuario

El soporte es un elemento importante a considerar cuando decidimos usar o no un
framework como base para nuestro sitio web. El soporte incluye documentación
bien escrita, conferencias web, foros comunitarios y (opcionalmente) servios de
soporte comercial como cursos y programas de certificación.

![Sitio web oficial de Zend Framework](../en/images/intro/zend_framework_site.png)

*Documentación*. La documentación de Zend Framework está ubicada en [esta dirección](https://framework.zend.com/learn).
Esta incluye tutoriales para aprendices, manuales de programación y la documentación
de la API (API significa Application Programming Interface).

*Foro comunitario*. Zend Framework tiene un canal IRC dedicado que se puede
usar para hacer preguntas. Este se encuentra en esta dirección: `irc://irc.freenode.net/zftalk`.

I> El canal de IRC (Internet Relay Chat) se puede abrir en una aplicación
I> cliente como [mIRC](http://www.mirc.com/). Pero si no nos gusta usar un cliente
I> podemos ver el canal desde una interfaz web mediante [este enlace](http://webchat.freenode.net/?channels=#zftalk).

*Conferencias webs*. Son video tutoriales que cubren varias de las características
de Zend Framework. Una lista completa de las conferencias
se encuentra en [este enlace](http://www.zend.com/en/resources/webinars/framework).

*Cursos de capacitación*. Con instructores en vivo, se puede acceder por
[este enlace]http://www.zend.com/en/services/training).
Aquí podemos aprender Zend Framework haciendo ejercicios,
pequeños proyectos y desarrollando código real.

*Programas de Certificación*. Nos permite convertirnos en un Ingeniero Zend Certificado (ZCE),
con facilidad podemos mejorar nuestros habilidades como arquitecto y encontrar un trabajo
dentro de un mercado competitivo de trabajo con PHP. Las certificaciones se encuentran [aquí](http://www.zend.com/en/services/certification).

## El código fuente del Framework

El código fuente de Zend Framework 3 esta guardado en los [repositorios](https://github.com/zendframework)
de GitHub, existe un repositorio separado para cada componente de ZF3.

I> En la mayoría de los casos no necesitaremos instalar el código de Zend Framework 3 manualmente.
I> En lugar de esto, lo instalaremos con el administrador de dependencias Composer.
I> Nos familiarizaremos con Composer luego en el capítulo llamado [Zend Skeleton Application](#skeleton).

### Estándar de Codificación

Es una buena práctica usar algún estándar de estilo de codificación para todo
nuestro código. Este estándar define reglas para nombres de clases,
formateo de código, etc. Zend Framework 3 define cada estándar [aquí](https://github.com/zendframework/zendframework/wiki/Coding-Standards).
Todo el código en ZF3 sigue las reglas descritas en ese documento.

T> Si planeamos escribir un sitio web basado en ZF3, es recomendable que sigas
T> el mismo estándar para tu propio código. Esto
T> hará nuestro código coherente y más fácil de extender y mantener por otras
T> personas.

## Sistemas Operativos Soportados

Como cualquier sitio web hecho con PHP, una aplicación web basada en ZF3 puede
funcionar sobre un servidor GNU/Linux o sobre cualquier otro sistema operativo
donde PHP pueda ejecutarse. Por ejemplo, para crear los ejemplos de
este libro, el autor uso la distribución de GNU/Linux Ubuntu.

Si no sabemos aun que sistema operativo usar para nuestro desarrollo web, es
recomendable usar GNU/Linux, porque la mayoría de los servidores webs funcionan con
distribuciones de GNU/Linux. Podemos revisar el [Apéndice A. Configurar un entorno web de desarrollo](#devenv) para
más instrucciones sobre la configuración de nuestro entorno de desarrollo.

## Requerimientos del Servidor

Zend Framework 3 necesita que nuestro servidor tenga instalada la versión de
PHP 5.6 o superior. Observe que es una requerimiento obligatorio. No todos
los alojamientos compartidos baratos y no todos los servidores privados tienen
una versión moderno de PHP.

Además, la manera recomendad de instalar ZF3 (y los otros componentes de los
que nuestra aplicación depende) es usando [Composer](http://getcomposer.org/).
Esto nos obliga a tener acceso SSH para poder ejecutar la herramienta de línea
de comandos. Algunos servicios de alojamiento dan acceso solamente por FTP
así que no seremos capaces de instalar una aplicación web basada en ZF3 en
esos servidor de la manera usual.

ZF3 usa la extensión de reescritura de URL para redirigir a los usuarios
al punto de entrada de nuestro sitio web (tenemos que activar el módulo de
Apache `mod_rewrite`). Además, podemos necesitar instalar alguna extensión
de PHP, como `memcached`. Esto puede ser una dificultad cuando usamos un
alojamiento web pues necesitamos tener privilegios de administrador en el
servidor.

Si estamos planeando usar ZF3 en un servicio de alojamiento compartido,
piénsalo dos veces. El mejor servidor donde instalar ZF3 es sobre un servidor
que tenga la última versión de PHP y con acceso a la consola con la capacidad
de ejecutar Composer e instalar las extensiones.

Si nuestra empresa administra sus propia infraestructura de servidores y es
capaz de actualizar PHP a la última versión podremos instalar ZF3 sin
problemas en nuestro servidor privado.

Una alternativa acceptable para instalar una aplicación web basada en ZF3
es usar un servicio de alojamiento "en la nube" como [Amazon Web Services](http://aws.amazon.com/).
Amazon provee instancias de sistemas GNU/Linux como parte de su servicio EC2.
EC2 es bastante barato y tiene una [modalidad gratuita](http://aws.amazon.com/free/)
que permite probarlo por un año gratuitamente. Damos instrucciones para los
principiantes de como instalar un sitio web con ZF3 en la nube EC2 de amazon
en el [Apéndice E. Instalar una Aplicación Web hecha con ZF3 en Amazon EC2](#ec2-tutorial)

## Seguridad

Zend Framework 3 sigue las mejores prácticas para darnos un código
base seguro para nuestro sitio web. Los creadores ZF3 publican parches de
seguridad una vez que la comunidad de usuarios encuentran un problema.
Podemos incorporar estas correcciones con un solo comando mediante el
administrador de dependencias Composer.

I> La práctica a demostrado que usar un framework para escribir un sitio web
I> es más seguro que usar PHP "puro" porque no necesitamos reinventar la rueda.
I> En un framework la mayoría de las vulnerabilidades ya se conocen y han
I> sido corregidas por la comunidad de usuarios.

ZF3 provee las siguientes características que hacen a nuestro sitio web
más seguro:

* *Script de entrada* (`index.php`) es el único script de PHP accesible a los
  visitantes. Todos los archivos PHP están almacenados fuera de la raíz de
  documentos de Apache. Esto es más seguro que permitir a todos visitar
  cualquiera de nuestros scripts de PHP.

* El *direccioamiento* (routing) permite definir reglas estrictas para establecer
  la URL de cada una de las páginas del sitio web. Si un usuario ingresa una URL
  invalida en la barra de navegación del navegador web aquel será redirigido
  automáticamente a la página de error.

* *Listas de Control de Acceso (ACL)* y *Control de Acceso Basado en Roles (RBAC)*
  permite definir reglas flexibles para permitir o negar el acceso a determinado
  recurso de nuestro sitio web. Por ejemplo, un usuario anónimo tendría acceso
  únicamente a nuestra página *index*, los usuarios autenticados tendrían acceso
  a su página de perfil y el usuario administrado tendría acceso al panel de
  administración del sitio.

* Los *validadores de formularios y filtros* aseguran que ningún dato no deseado
  se colecte a través de los formularios web. Los filtros, por ejemplo, permiten
  cortar las cadenas de caracteres y quitar las etiquetas HTML. Los validadores
  se usan para revisar que los datos que se han enviado a través del formulario
  cumplen determinadas reglas. Por ejemplo, el validador de correo electrónico
  revisa que un campo *email* contiene un correo electrónico valido y si no es
  así lanza un error que obliga al usuario del sitio a corregir los errores de
  entrada.

* *Captcha* y *CSRF* (Cross-Site Request Forgery) son elementos del formulario
  que respectivamente se usan para revisar si el usuario es humano y para
  prevenir los ataques de los crackers.

* El componente *Zend\Escaper* permite quitar las etiquetas HTML indeseadas
  de los datos de salida, los datos que se imprimen en las páginas.

* El *soporte criptográfico* permite guardar datos sensibles (ejemplo, credenciales)
  codificadas con algoritmos criptográficos fuertes que son difíciles de romper.

## Rendimiento

ZF3 provee las siguientes características para asegurar un rendimiento
aceptable:

  * *Lazy class autoloading.* Las clases se cargan solo cuando se necesitan.
    No tenemos que escribir `require_once` para cada clase que queremos cargar.
    En su lugar, el framework descubre automáticamente las clases usando la
    característica *autoloader*.

  * *Carga eficiente de servicios y complementos.* En ZF3 las clases se instancian
    solo cuando ellas realmente se necesitan. Esto se consigue a través del
    administrador de servicios (el contenedor central para servicios de nuestra
    aplicación).

  * *Soporta cacheo.* PHP tiene varias extensiones para hacer cache (como Memcached)
    que se pueden usar para acelerar los sitios web. La cache frecuentemente
    guarda los datos usados en memoria para acelerar su recuperación.

## Patrones de Diseño

Los creadores de Zend Framework 3 son grandes fanáticos de varios patrones de
diseño. Aunque no tenemos que saber sobre patrones para leer este libro esta
sección se propone darnos una idea sobre los patrones de diseño en los que
está basado ZF3.

* *El patrón Modelo-Vista-Controlador (MVC)*. El patrón Modelo-Vista-Controlador
  se usa en todos los frameworks modernos de PHP. En una aplicación MVC separamos
  el código en tres categorías: modelos (nuestra lógica de negocio va aquí),
  vistas (nuestra presentación va aquí) y los controladores (el código reusable
  para interactuar con los usuarios va aquí). A esto además se le llama
  *separación de conceptos*. Con MVC, podemos *reusar* nuestros componentes.
  Además, es fácil substituir cualquier parte de esta tríada. Por ejemplo,
  podemos fácilmente reemplazar una vista por otra sin cambiar la lógica de
  negocio.

* *El patrón de Diseño Guiado por Dominio (DDD)*. En Zend Framework 3, por
  convención, tendremos la capa de modelo dividida en *entidades* (clases
  asociadas a tablas de base de datos), *repositories* (clases usadas para
  recuperar entidades de la base de datos), *objetos con valor* (clases de
  modelo que no tienen identidad), *servicios* (clases responsables de la
  lógica de negocio).

* *El patrón de Diseño Orientado a Aspectos.* En ZF3 todo está manejado por un
  evento. Cuando un usuario del sitio pide una página un *evento* se genera
  (lanzador). Un oyente (u observador) puede capturar el evento y hacer algo
  con el. Por ejemplo, el componente `Router` analiza la URL y determina a que
  clase controlador llamar. Cuando el evento finalmente llega a la impresión
  de la página una respuesta HTTP se genera y el usuario ve la página.

* *Patrón de Instancia Única.* En ZF3 existe una objeto administrador de
  servicios que es el contenedor centralizado de todos los servicios disponibles
  en la aplicación. Cada servicio existe en una instancia única.

* *El Patrón Estrategia.* Una estrategia es solo una clase que encapsula algún
  algoritmo. Podemos usar diferentes algoritmos basados en alguna condición.
  Por ejemplo, la página que se imprime tiene varias estrategias de impresión
  que hace posible imprimir páginas de manera diferente (el proceso de
  impresión puede generar una página HTML, una respuesta JSON, un RSS, etc.)

* *El Patrón Adaptador*. Los adaptadores permiten adaptar una clase genérica a
  un caso de uso concreto. Por ejemplo, el componente `Zend\Db` provee acceso
  a la base de datos de una forma genérica. Internamente, se usan adaptadores
  para cada base de datos soportada (SQLite, MySQL, PostgreSQL, etc.)

* *El Patrón Fábrica.* Podemos crear una instancia de una clase usando el
  operador `new`. O podemos crearla con una fábrica. Una fábrica es solo una
  clase que encapsula la creación de otros objetos. Las fábricas son útiles
  porque ellas simplifican la inyección de dependencias. Además, usar fábricas
  simplifica las pruebas de nuestro modelo y de las clases controladores.

## Principales Componentes de ZF3

Los desarrolladores de ZF3 creen que el framework debe ser un conjunto de
componentes desacoplables con un mínimo de dependencias entre ellos. Así es
como ZF3 está organizado.

La idea es que se puedan usar los componentes de ZF3 separadamente, incluso
si estamos escribiendo nuestro sitio web con otro framework. Esto facilita las
cosas aún más si tenemos en mente que cada componente de ZF3 es una paquete
que se puede instalar usando Composer, así podemos fácilmente instalar cualquier
componente de ZF3 junto con sus dependencias usando solo un comando.

Existen varios componentes "principales" en ZF3 que se usan explícitamente
o implícitamente en casi cualquier aplicación web:

  * El componente `Zend\EventManager` permite enviar eventos y registrar oyentes
    que reaccionan a ellos.

  * `Zend\ModuleManager`. En ZF3, cada aplicación está constituida por módulos
    y este componente contiene las funcionalidades necesarias para cargarlos.

  * `Zend\ServiceManager`. Este es el registro centralizado de todos los
    servicios disponibles en la aplicación y permite acceder a los servicios
    desde cualquier punto de la página web.

  * `Zend\Http` provee una interfaz simple para manejar las peticiones HTTP
    (Hyper-Text Transfer Protocol)

  * `Zend\Mvc`. Provee el soporte para el patrón Modelo-Vista-Controlador y
    para la separación de la lógica del negocio de la presentación.

  * `Zend\View`. Provee un sistema de ayudantes, filtros de salida y escape
    de variables usados en la capa de presentación.

  * `Zend\Form`. Colección de formularios web, filtros, validación e impresión.

  * `Zend\InputFilter`. Provee la capacidad de definir reglas para la validación
    de formularios.

  * `Zend\Filter`. Provee un conjunto de filtros de datos usados comúnmente
    como los cortadores de cadenas.

  * `Zend\Validator`. Provee un conjunto de validadores usados comúnmente.

## Diferencias con Zend Framework 2

Para los lectores que han experimentado con Zend Framework 2 daremos en esta
sección información sobre lo que ha cambiado en Zend Framework 3.

Abajo presentamos las principales diferencias técnicas entre ZF2 y ZF3:

### Retrocompatibilidad

ZF3 es una versión evolutiva así que la retrocompatibilidad se preserva en la
mayoría de los caso. Sin embargo, algunos trabajos de migración tienen que
hacerse si usamos `ServiceLocatorAwareInterface` a lo largo del código,
lo que es probable. En ZF3, esta interfaz se ha removido y ahora todas las
dependencias se deben inyectar a través de fábricas. Así, tendremos que crear
fábricas para la mayoría de los controladores, servicios, ayudantes de vista
y complementos de controlador.

### Componentes

En ZF2 los componentes estaban guardados en un solo repositorio GIT. En ZF3
los componentes son guardados en multiples repositorios GIT, un repositorio
por cada componente (por ejemplo, `zendframework/zend-mvc`,
`zendframework/zend-servicemanager`, `zendframework/zend-form`, etc).
Esto permite desarrollar y publicar componentes independientemente uno de otro.

Los componentes son más fáciles de desacoplar que antes y tienen un mínimo de
dependencias uno del otro. El componente `Zend\Mvc` se ha divido en varios
componentes. Por ejemplo, las funcionalidades para el enrutamiento se han
separado y colocado en el nuevo componente `Zend\Router`.

Ahora se recomienda especificar las dependencias individualmente en el archivo
`composer.json`, aunque aún es posible depender del paquete `zendframework/zendframework`
que es un metapaquete que instala *todos* los componentes disponibles.

### Instalador de Componentes

En ZF3 un complemente especial de Composer llamado *component installer* se
introdujo. Este permite instalar componentes como módulos de ZF. Además, inyecta
información sobre los componentes dentro del archivo de configuración de la
aplicación.

### Rendimiento del ServiceManager y del EventManager

Los desarrolladores de ZF3 hicieron un gran trabajo mejorando el rendimiento
de los componentes `ServiceManager` y `EventManager`. Ellos son ahora varias
veces más rápidos que antes. La desventaja es que tenemos que hacer un
trabajo de migración para poder usar las nuevas funcionalidades. Ahora, en los nombre
de los controladores y los servicios se recomienda utilizar la característica
de PHP 5.5 llamada `::class`. Por ejemplo, si antes registramos nuestro
controlador como `Application\Controller\Index`, ahora lo registraremos como
`IndexController::class`. Si antes registrábamos los nombres de los servicios
como queríamos ahora se recomienda hacerlo usando `ServiceClassName::class`.
Podemos leer la documentación del componente `Mvc` para información adicional.

### PSR-4

En ZF2 la estructura de carpetas recomendada fue PSR-0, mientras que en ZF3 es
PSR-4. Esto requiere algunos (pequeños) trabajos de migración.

### Middleware

Zend cree que el futuro de PHP está en ser un middleware. "Middleware es, dicho
con simplicidad, código ubicado entre una petición HTTP entrate y una respuesta
HTTP saliente." Ahora podemos registrar un middleware que maneje eventos
en una aplicación MVC.

### Enfoque sobre la documentación

Ahora cada componente en su repositorio contiene su propia documentación. La
documentación esta ahora en formato Markdown y tiene mejor diseño.

## Resumen

Un framework de PHP es una biblioteca que nos da código base y una manera
consistente de crear aplicaciones web. Zend Framework 3 es un moderno framework
de desarrollo web creado por Zend Technologies, el mantenedor del lenguaje PHP.
Provee a los desarrolladores de capacidades destacadas para construir sitios
web escalables y seguros. ZF3 usa una licencia tipo BSD que le permite ser
usado tanto en aplicaciones libres como en aplicaciones comerciales.
