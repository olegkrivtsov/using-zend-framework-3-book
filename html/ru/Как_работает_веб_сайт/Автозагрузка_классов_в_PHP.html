<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="description" content="A free and open-source book about Zend Framework">
<meta name="keywords" content="php,zend framework,book,tutorial,documentation,learn,free">
<meta name="author" content="(c) 2016 by Oleg Krivtsov">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../../favicon.ico" rel="shortcut icon" type="image/ico" />
<link href="../../assets/css/style.css" type="text/css" rel="stylesheet" />
<title>Автозагрузка классов в PHP -- Using Zend Framework 3</title>
</head>
<body>
<header>
    <div class="header">
        <div class="header-body">
            <div class="book-title">
                <a href="../../index.html">Using Zend Framework 3</a>
            </div>
            <div class="book-subtitle">
                A free and open-source book about Zend Framework            </div>
            <nav>
                <div class="menu">
                                        <div class="link">
                        <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/html">Read</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zf3-book-samples">Samples</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zend-framework-3-book">Contribute</a>
                    </div>
                    
                </div>
            </nav>
        </div>    
    </div>
</header>    
<div id="container">
<!-- Navigation -->
<div class="navigation">
    <div class="prev-chapter">
        
        <a href="../Как_работает_веб_сайт/Интерфейсы_PHP.html">
            <img alt="Previous Chapter" src="../../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="../toc.html">
            <img alt="Contents" src="../../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="../Как_работает_веб_сайт/HTTP_запросы_и_ответы.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../../assets/images/right.png">
        </a>
            </div>
        <div class="current-chapter">
        <a href="../Как_работает_веб_сайт.html">
            <img alt="Contents" src="../../assets/images/upload.png"><span class="nav-btn-text">Как работает веб-сайт</span>
        </a>
    </div>
    </div>


<!-- Chapter content -->
<div id="chapter_content">

<h2 id="Автозагрузка_классов_в_PHP">3.3. Автозагрузка классов в PHP</h2>
<p>Веб-приложение состоит из множества PHP-классов,  и каждый класс, как правило, располагается
в отдельном файле. Это приводит к необходимости <em>включения (including)</em> файлов.</p>
<p>Предположим, например, что у нас есть файл с именем <em>Application.php</em>, который
содержит определение класса <code>\Zend\Mvc\Application</code> из предыдущего раздела.
Перед тем как создать экземпляр этого класса где-либо в своем коде, вы должны
включить содержимое файла <em>Application.php</em> (это можно сделать с помощью оператора
<code>require_once</code>, передав ему полный путь к файлу):</p>
<pre class=""><code class="language-php">&lt;?php
require_once "/path/to/zendframework/zend-mvc/src/Application.php";

use Zend\Mvc\Application;

$application = new Application;
</code></pre>
<p>С увеличением размера вашего приложения включение каждого необходимого файла
может вызывать трудности. Сам Zend Framework 3 состоит из сотен файлов, и 
загружать целую библиотеку и все ее зависимости таким образом довольно сложно.
Более того, при запуске кода интерпретатору PHP потребуется процессорное время для
обработки каждого включенного файла, даже если вы не создавали экземпляр его класса.</p>
<p>Для решения этой проблемы в PHP была введена опция автозагрузки классов.
Функция <code>spl_autoload_register()</code> позволяет вам зарегистрировать функцию
<em>автозагрузки</em>. Для сложных сайтов можно даже создать несколько функций
автозагрузки, объединенные в стек.</p>
<p>Если интерпретатор PHP во время выполнения скрипта сталкивается с именем класса,
которое еще не было определено, он вызывает все зарегистрированные функции 
автозагрузки по порядку до тех пор, пока какая либо функция автозагрузки не включит класс. 
Если же ни одна из функций автозагрузки не сделает этого, будет выброшена ошибка "not found". 
Это делает возможным "ленивую" загрузку, при которой
интерпретатор обрабатывает определение класса только в момент его вызова - когда он
на самом деле нужен.</p>
<p>Чтобы дать вам представление о том, как выглядит функция автозагрузки, ниже мы
привели ее упрощенную реализацию:</p>
<pre class=""><code class="language-php">&lt;?php
// Функция автозагрузки.
function autoloadFunc($className) 
{
  // Статический массив карты классов.
  static $classMap = [
    '\\Zend\\Mvc\\Application' =&gt; '/path/to/zendframework/zend-mvc/src/Zend/Mvc/Application.php',
    '\\Application\\Module' =&gt; '/path/to/app/dir/module/Application/Module.php',
    //...
  ];

  // Проверяем, находится ли такое имя класса в карте классов.
  if(isset(static::$classMap[$className])) {
    $fileName = static::$classMap[$className];
  
    // Проверяем, существует ли файл и возможно ли его прочитать.
    if (is_readable($filename)) {
      // Подлючаем файл.
      require $filename;
    }
  }
}

// Регистрируем нашу функцию автозагрузки.
spl_autoload_register("autoloadFunc");
</code></pre>
<p>В примере выше мы определяем функцию автозагрузки <code>autoloadFunc()</code>, которую
в дальнейшем будем именовать автозагрузчиком <em>карты классов</em> (class map autoloader).</p>
<p>Автозагрузчик карты классов использует карту для определения соответствия между именем
класса и абсолютным путем к PHP-файлу, содержащему этот класс. Карта классов - это всего лишь
обычный PHP-массив, содержащий ключи и значения. Чтобы определить путь к файлу по имени класса,
автозагрузчику просто нужно взять значение из массива карты классов. Очевидно, что автозагрузчик
работает очень быстро. Однако, его минус в том, что вам необходимо поддерживать карту классов и
обновлять ее каждый раз при добавлении в программу нового класса.</p>
<h3 id="Стандарт_PSR_4">3.3.1. Стандарт PSR-4</h3>
<p>Так как каждый поставщик библиотек использует свои собственные правила наименования и организацию файлов,
вам придется регистрировать свою функцию автозагрузки для каждой зависимой библиотеки, что, конечно,
может надоедать (и вообще, это ненужный труд). Чтобы решить эту проблему, был введен стандарт PSR-4.</p>
<blockquote class="notquote information" data-type="information"><p> PSR расшифровывается PHP Standards Recommendation (рекомендации стандартов PHP).</p>
</blockquote><p><a href="http://www.php-fig.org/psr/psr-4/">Стандарт PSR-4</a> 
определяет рекомендованную структуру кода, которую приложение или библиотека должны соблюдать,
чтобы обеспечить совместимость механизмов автозагрузки.</p>
<ul>
<li><p>Пространства имен класса должны быть организованы следующим образом: </p>
<p><code>\&lt;Имя поставщика&gt;\(&lt;Пространство имен&gt;)*\&lt;Имя класса&gt;</code></p>
</li>
<li><p>Пространства имен могут иметь любое желаемое количество уровней вложенности,
но <em>имя поставщика</em> должно быть пространством имен верхнего уровня.</p>
</li>
<li><p>Пространства имен должны иметь соответствие один к одному со структурой каталогов. Каждый разделитель пространств имен (<code>\</code>)
конвертируется в константу <code>DIRECTORY_SEPARATOR</code>, отличную для разных ОС.</p>
</li>
<li><p>К имени класса добавляется суффикс расширения <em>.php</em> при загрузке файла из файловой системы.</p>
</li>
</ul>
<p>Например, для класса <code>Zend\Mvc\Application</code>, у вас будет следующая структура каталогов:</p>
<pre class=""><code class="language-text">/path/to/zendframework/zend-mvc/src
  /Zend
    /Mvc
       Application.php
</code></pre>
<p>Недостатком данной структуры является то, что вам придется размещать свои классы внутри ряда вложенных пустых 
дректорий (<em>Zend</em> и <em>Mvc</em>).</p>
<p>Чтобы исправить это, PSR-4 позволяет сопоставить последовательности одного или нескольких пространств и подпространств имен "базовый каталог". 
Например, если у вас есть полностью определенное имя класса <code>\Zend\Mvc\Application</code> и вы определяете соответствие
между <code>\Zend\Mvc</code> и каталогом "/path/to/zendframework/zend-mvc/src/", вы можете организовать файлы следующим образом:</p>
<pre class=""><code class="language-text">/path/to/zendframework/zend-mvc/src
    Application.php
</code></pre>
<p>Для соответствующего стандарту PSR-4 кода, мы можем написать и зарегистрировать автозагрузчик,
который будем именовать "стандартным" автозагрузчиком:</p>
<pre class=""><code class="language-php">&lt;?php

// "Стандартный" автозагрузчик.
function standardAutoloadFunc($className) 
{
  // Заменить префикс пространства имен на базовую директорию.
  $prefix = '\\Zend\\Mvc';
  $baseDir = '/path/to/zendframework/zend-mvc/src/';
  if (substr($className, 0, strlen($prefix)) == $prefix) {
    $className = substr($className, strlen($prefix));
    $className = $baseDir . $className;
  }

  // Заменить разделители пространства имен на разделители директорий.
  $className = str_replace('\\', DIRECTORY_SEPARATOR, $className);
  
  // Добавить расширение .php.
  $fileName = $className . ".php";
  
  // Проверить, что файл существует и его можно прочесть.
  if (is_readable($fileName)) {
    // Включить файл.
    require $fileName;
  } 
}

// Register the autoloader function.
spl_autoload_register("standardAutoloadFunc");
</code></pre>
<p>Стандартный автозагрузчик работает следующим образом:
Предполагая, что пространство имен класса имеет соответствие один к одному со структурой каталогов,
функция вычисляет путь к PHP-файлу, преобразовывая обратные слеши (разделители пространств имен) в
прямые (разделители пути) и соединяя полученный путь с абсолютным путем к каталогу, где расположена
библиотека. Затем функция проверяет, существует ли уже такой PHP-файл, и, если он существует, включает
его с помощью оператора <code>require</code>.</p>
<p>Очевидно, что стандартный автозагрузчик работает медленнее, чем автозагрузчик карты классов.
Однако, его преимущество в том, что вам не нужно поддерживать карту классов, что очень удобно
при написании нового кода и добавлении новых классов к вашему приложению.</p>
<blockquote class="notquote information" data-type="information"><p> Zend Framework 3 работает в соответствии со стандартом PSR-4, что делает возможным 
 автозагрузку всех его компонентов. Он также совместим с другими библиотеками, следующими
 PSR-4, такими как Doctrine и Symfony.</p>
</blockquote><h3 id="Автозагрузчик__предоставляемый_Composer_ом">3.3.2. Автозагрузчик, предоставляемый Composer'ом</h3>
<p>Zend Framework 3 использует реализацию механизмов автозагрузки, предоставляемую Composer'ом. При установке пакетов
Composer автоматически создается файл <em>APP_DIR/vendor/autoload.php</em>,
использующий функцию <code>spl_autoload_register()</code>, чтобы зарегистрировать автозагрузчик. Таким образом, все PHP-классы,
находящиеся в каталоге <code>APP_DIR/vendor</code> , корректно загружаются автоматически.</p>
<p>Для автозагрузки PHP-классов, расположенных в ваших собственных модулях (например, в модуле <code>Application</code>), вам нужно будет
указать ключ <code>autoload</code> в файле <code>composer.json</code>:</p>
<pre class=""><code class="language-json",title="Autoload key of composer.json file">"autoload": {
    "psr-4": {
        "Application\\": "module/Application/src/"
    }
},
</code></pre>
<p>Затем все, что нужно будет сделать, это включить этот файл во входном скрипте <code>index.php</code> вашего веб-сайта:</p>
<pre class=""><code class="language-php">// Автозагрузка Composer'a
include __DIR__ . '/../vendor/autoload.php';
</code></pre>
<h3 id="PSR_4_и_структура_исходных_каталогов">3.3.3. PSR-4 и структура исходных каталогов</h3>
<p>В Zend Skeleton Application вы можете наблюдать стандарт PSR-4 на практике. 
Для стандартного модуля вашего сайта, модуля <code>Application</code>, PHP-классы, 
зарегистрированные стандартным автозагрузчиком, хранятся в каталоге <code>APP_DIR/module/Application/src</code> 
("src" - сокращение от "source" - "источник"). </p>
<blockquote class="notquote information" data-type="information"><p> Мы будем называть каталог <code>src</code> исходным каталогом модуля.</p>
</blockquote><p>Для примера рассмотрим файл <code>IndexController.php</code> модуля <code>Application</code> (рисунок 3.2). </p>
<p><span class="image-wrapper">
<a target="_blank" href="../../en/images/operation/psr0_and_dir_structure.png">
<img src="../../en/images/operation/psr0_and_dir_structure.png" alt="Рисунок 3.2. Структура каталогов скелетного приложения соответствует стандарту PSR-4" /></a>
<span class="image-caption">Рисунок 3.2. Структура каталогов скелетного приложения соответствует стандарту PSR-4</span>
</span>
</p>
<p>Как видите, он содержит класс <code>IndexController</code> <sup id="fnref:контроллер"><a href="#fn:контроллер" class="footnote-ref" rel="footnote">1</a></sup>, принадлежащий пространству имен <code>Application\Controller</code>. 
Чтобы соблюдать стандарт PSR-4 и использовать стандартный автозагрузчик с этим классом, 
нужно поместить его в директорию <code>Controller</code> в исходном каталоге модуля. </p>
<footnotes id="fn:контроллер"><p><sup>1)</sup> Класс <code>IndexController</code> - это стандартный контроллер для скелетного сайта. 
Мы будем говорить о контроллерах в главе <a href="../Модель_представление_контроллер.html">Модель-представление-контроллер</a>.</p>
</footnotes>
        
</div>

    
<!-- Navigation -->
<div class="navigation">
        <div class="current-chapter">
        <a href="../Как_работает_веб_сайт.html">
            <img alt="Contents" src="../../assets/images/upload.png"><span class="nav-btn-text">Как работает веб-сайт</span>
        </a>
    </div>
        <div class="prev-chapter">
        
        <a href="../Как_работает_веб_сайт/Интерфейсы_PHP.html">
            <img alt="Previous Chapter" src="../../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="../toc.html">
            <img alt="Contents" src="../../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="../Как_работает_веб_сайт/HTTP_запросы_и_ответы.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../../assets/images/right.png">
        </a>
            </div>        
</div>

<div id="disqus_thread"></div>

        
</div>
<footer>
    <div class="footer">
        <div class="footer-body">
            <div class="copyright">
                Copyright (c) 2016 by Oleg Krivtsov            </div>
            <div class="generated-by">
                Generated using <a href="https://github.com/olegkrivtsov/openbook">OpenBook</a>
            </div>
        </div>    
    </div>
</footer>

<a href="#0" class="cd-top">Top</a>

<script src="../../assets/js/jquery.min.js"></script>
<script src="../../assets/js/loadCSS.js"></script>

<script src="../../assets/js/prism.js"></script>

<script>
var disqus_config = function () {
this.page.url = window.location.href; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//using-zend-framework-3-book.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script>
loadCSS("../../assets/css/prism.css");
</script>

<script>
jQuery(document).ready(function($){
    // browser window scroll (in pixels) after which the "back to top" link is shown
    var offset = 300,
    //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
    offset_opacity = 1200,
    //duration of the top scrolling animation (in ms)
    scroll_top_duration = 700,
    //grab the "back to top" link
    $back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
            ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
            if( $(this).scrollTop() > offset_opacity ) { 
                    $back_to_top.addClass('cd-fade-out');
            }
    });

    //smooth scroll to top
    $back_to_top.on('click', function(event){
            event.preventDefault();
            $('body,html').animate({
                    scrollTop: 0 ,
                    }, scroll_top_duration
            );
    });

});
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-80824388-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>    

