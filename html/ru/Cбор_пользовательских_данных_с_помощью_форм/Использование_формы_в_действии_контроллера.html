<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="description" content="A free and open-source book about Zend Framework">
<meta name="keywords" content="php,zend framework,book,tutorial,documentation,learn,free">
<meta name="author" content="(c) 2017 by Oleg Krivtsov">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="../../favicon.ico" rel="shortcut icon" type="image/ico" />
<link href="../../assets/css/style.css" type="text/css" rel="stylesheet" />
<title>Использование формы в действии контроллера -- Using Zend Framework 3</title>
</head>
<body>
<header>
    <div class="header">
        <div class="header-body">
            <div class="book-title">
                <a href="../../index.html">Using Zend Framework 3</a>
            </div>
            <div class="book-subtitle">
                A free and open-source book about Zend Framework            </div>
            <nav>
                <div class="menu">
                                        <div class="link">
                        <a href="https://olegkrivtsov.github.io/using-zend-framework-3-book/html">Read</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zf3-book-samples">Samples</a>
                    </div>
                                        <div class="link">
                        <a href="https://github.com/olegkrivtsov/using-zend-framework-3-book">Contribute</a>
                    </div>
                    
                </div>
            </nav>
        </div>    
    </div>
</header>    
<div id="container">
<!-- Navigation -->
<div class="navigation">
    <div class="prev-chapter">
        
        <a href="../Cбор_пользовательских_данных_с_помощью_форм/Добавление_правил_валидации_формы.html">
            <img alt="Previous Chapter" src="../../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="../toc.html">
            <img alt="Contents" src="../../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="../Cбор_пользовательских_данных_с_помощью_форм/Представление_формы.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../../assets/images/right.png">
        </a>
            </div>
        <div class="current-chapter">
        <a href="../Cбор_пользовательских_данных_с_помощью_форм.html">
            <img alt="Contents" src="../../assets/images/upload.png"><span class="nav-btn-text">Cбор пользовательских данных с помощью форм</span>
        </a>
    </div>
    </div>

﻿<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Using Zend Framework 3 Book - Chapter - Adaptive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3933778336056438"
     data-ad-slot="4531860323"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<!-- Chapter content -->
<div id="chapter_content">

<h2 id="Использование_формы_в_действии_контроллера">7.11. Использование формы в действии контроллера</h2>
<p>Когда класс модели формы будет готов, вы наконец сможете использовать форму
в методе действия контроллера.</p>
<p>Как вы уже, возможно, знаете, то, как пользователь работает с формой - это, как правило,
итеративный процесс (схематически изображен на рисунке 7.18):</p>
<p><span class="image-wrapper">
<a target="_blank" href="../../en/images/forms/form_workflow.png">
<img src="../../en/images/forms/form_workflow.png" alt="Рисунок 7.18. Типичный процесс использования формы" /></a>
<span class="image-caption">Рисунок 7.18. Типичный процесс использования формы</span>
</span>
</p>
<ul>
<li>Сперва вы отображаете форму и ее поля на веб-странице, предлагая пользователю ввести данные.
Как только пользователь заполнит поля, он нажмет на кнопку <em>Submit</em>, отправив данные серверу.</li>
<li>Затем ваш контроллер извлекает эти данные и запрашивает их валидацию у модели формы. Если были
какие-либо ошибки ввода, форма отображается снова, предлагая пользователю их исправить. Если данные
корректны, вы обрабатывается данные с помощью уровня бизнес-логики и (обычно) перенаправляете пользователя
на другую веб-страницу.</li>
</ul>
<p>Базовый класс <code>Form</code> предоставляет для этих целей несколько методов (см. таблицу 7.11).</p>
<div class="table-wrapper">
<div class="table-caption">Таблица 7.11.Методы, предоставляемые базовым классом Form</div><table>
<thead>
<tr>
<th> <em>Имя метода </em>                  </th>
<th> <em>Описание</em>                                                    </th>
</tr>
</thead>
<tbody>
<tr>
<td>  <code>setData($data)</code>               </td>
<td>  Задает данные формы для валидации.                            </td>
</tr>
<tr>
<td> <code>getData($flag)</code>               </td>
<td> Извлекает валидированные данные.                              </td>
</tr>
<tr>
<td> <code>isValid()</code>                    </td>
<td> Валидирует форму.                                             </td>
</tr>
<tr>
<td> <code>hasValidated()</code>               </td>
<td> Проверяет, была ли форма валидирована.                        </td>
</tr>
<tr>
<td> <code>getMessages($elementName = null)</code>                                 </td>
<td> Возвращает список сообщений о неудачных валидациях, если     такие есть, для одного элемента или для всех элементов формы. </td>
</tr>
</tbody>
</table>
</div>
<p>Таким образом, общий процесс использования формы таков:</p>
<ul>
<li><p>Проверяем, были ли отправлены данные формы, и, если нет, отображаем форму на веб-странице.</p>
</li>
<li><p>Если данные были отправлены пользователем, необработанные данные извлекаются из
переменных <code>POST</code> и/или <code>GET</code> в виде массива.</p>
</li>
<li><p>Данные присваиваются полям модели формы с использованием метода <code>setData()</code>.</p>
</li>
<li><p>Выполняются фильтрация и валидация с использованием метода <code>isValid()</code>
(это приводит к выполнению фильтра входных данных, присоединенного к форме).
Если определенное поле (или поля) недействительно(ы), форма отображается снова,
и пользователю предлагается исправить данные.</p>
</li>
<li><p>Как только данные прошли фильтрацию и валидацию, они извлекаются из модели
формы методом <code>getData()</code> и передаются другим моделям либо используются любым другим способом.</p>
</li>
</ul>
<p>Пример кода ниже показывает, как реализовать этот процесс в методе действия контроллера:</p>
<pre class="line-numbers"><code class="language-php">&lt;?php
namespace Application\Controller;

use Application\Form\ContactForm;
// ...

class IndexController extends AbstractActionController 
{
    // Это действие отображает форму обратной связи
    public function contactUsAction() 
    {
        // Создаем форму
        $form = new ContactForm();
        
        // Проверяем, отправил ли пользователь форму
        if($this-&gt;getRequest()-&gt;isPost()) 
        {
            // Заполняем форму POST-данными
            $data = $this-&gt;params()-&gt;fromPost();            
            $form-&gt;setData($data);
            
            // Валидируем форму
            if($form-&gt;isValid()) {
                
                // Получаем фильтрованные и валидированные данные
                $data = $form-&gt;getData();
                
                // ... Какие-то действия с валидированными данными ...
		
                // Перенаправление на страницу "Спасибо"
                return $this-&gt;redirect()-&gt;toRoute('application', ['action'=&gt;'thankYou']);
            }            
        } 
        
        // Передаем переменную формы представлению
        return new ViewModel([
           'form' =&gt; $form
        ]);
    }
}
</code></pre>
<p>В этом фрагменте мы определяем метод действия <code>contactUsAction()</code> в классе <code>IndexController</code> (строка 10).
В методе действия мы создаем экземпляр класса <code>ContactForm</code> (строка 13).</p>
<p>Затем в строке 16 мы проверяем, является ли запрос POST-запросом (проверяя первую строку HTTP-запроса).</p>
<p>В строке 19 мы извлекаем необработанные данные, отправленные пользователем. Все переменные POST
извлекаются с помощью плагина контроллера <code>Params</code>. Данные возвращаются в форме массива и сохраняются
в переменную <code>$data</code>.</p>
<p>Данные, отправленные пользователем, могут содержать ошибки и должны пройти фильтрацию и валидацию перед
дальнейшим использованием. Для этого в строке 20 мы задаем эти данные модели с помощью метода <code>setData()</code> базового
класса <code>Form</code>. Мы затем валидируем данные формы методом <code>isValid()</code> (строка 23), который возвращает значение <code>true</code>
при успешной валидации. Если валидация проходит успешно, мы извлекаем валидированные данные с помощью метода <code>getData()</code>
(строка 26) и затем можем передать их уровню бизнес-логики.</p>
<p>После использования валидированных данных мы перенаправляем веб-пользователю на страницу <em>Thank You</em> (строка 31).
Перенаправление осуществляется с помощью плагина контроллера <code>Redirect</code>. Метод этого плагина <code>toRoute()</code> принимает
два параметра: первый параметр - имя маршрута ("application"), а второй - массив параметров, которые нужно передать
маршрутизатору. Эти параметры определяют страницу, куда перенаправляется пользователь.</p>
<blockquote class="notquote information" data-type="information"><p> Мы подготовим действие контроллера и шаблон представления для страницы благодарности
 немного позже.</p>
</blockquote><p>В строке 37 мы передаем модель формы шаблону представлению через переменную <code>$form</code>. Шаблон представления
будет обращаться к этой переменной и использовать ее для визуализации формы (и возможных ошибок валидации).</p>
<h3 id="Передача_модели_данных_формы">7.11.1. Передача модели данных формы</h3>
<p>В качестве реального примера использования валидированных данных формы обратной связи, в этом
примере мы создадим простой класс модели <code>MailSender</code> <sup id="fnref:сервис"><a href="#fn:сервис" class="footnote-ref" rel="footnote">?</a></sup>, которая может быть использована
для отправки электронного сообщения на адрес электронной почты. Когда пользователь отправит форму,
мы проведем валидацию данных формы, а затем передадим валидированные данные модели <code>MailSender</code> и
потребуем отправить сообщение электронной почты получателю.</p>
<footnotes id="fn:service"><p><sup>24)</sup> С точки зрения DDD, <code>MailSender</code> можно отнести к моделям сервисов, так как ее задачей
является управление данными, а не их хранение.</p>
</footnotes>
<blockquote class="notquote tip" data-type="tip"><p> Этот раздел по большей части предназначен для начинающих. Вы можете пропустить его и
 сразу перейти к следующему разделу <em>Представление формы</em>.</p>
</blockquote><p>Модель <code>MailSender</code> будет внутренне использовать компонент <code>Zend\Mail</code>. Этот компонент, предоставляемый
Zend Framework 3, предназначен для обеспечения разработчика удобной функциональностью для составления
почтовых сообщений (класс <code>Zend\Mail\Message</code>) и несколькими классами, реализующими доступные методы
передачи (в этом примере мы будем использовать класс <code>Mail\Transport\Sendmail</code>, который использует программу
<em>sendmail</em> для доставки электронной почты).</p>
<blockquote class="notquote information" data-type="information"><p> Установите компонент <code>Zend\Mail</code> с помощью Composer'a, прописав следующую команду:</p>
<p> <code>php composer.phar require zendframework\zend-mail</code></p>
</blockquote><blockquote class="notquote information" data-type="information"><p> Программа <a href="http://www.sendmail.com/sm/open_source/">sendmail</a> - распространяемый бесплатно вместе с исходными кодами
 агент передачи почты для операционных систем Linux/Unix. Он принимает сообщения, передаваемые ему PHP-скриптом, решает, 
 какой метод доставки использовать, в зависимости от заголовка сообщения, и затем передает сообщение через протокол
 SMTP на почтовый сервер (например, Google Mail) для доставки получателю.</p>
</blockquote><p>Начнем с создания файла <em>MailSender.php</em> под каталогом <em>Service</em> под корневым каталогом 
модуля (см. рисунок 7.19).</p>
<p><span class="image-wrapper">
<a target="_blank" href="../../en/images/forms/mailsender.png">
<img src="../../en/images/forms/mailsender.png" alt="Создание 7.19. Создание файла MailSender.php" /></a>
<span class="image-caption">Создание 7.19. Создание файла MailSender.php</span>
</span>
</p>
<p>Ниже представлен код, который нужно поместить в файл <em>MailSender.php</em>:</p>
<pre class="line-numbers"><code class="language-php">&lt;?php
namespace Application\Service;

use Zend\Mail;
use Zend\Mail\Message;
use Zend\Mail\Transport\Sendmail;

// Этот класс используется для доставки электронного письма получателю.
class MailSender 
{
    // Отправляет эл. сообщение.
    public function sendMail($sender, $recipient, $subject, $text) 
    {
        $result = false;
        try {
        
            // Создаем эл. сообщение
            $mail = new Message();
            $mail-&gt;setFrom($sender);
            $mail-&gt;addTo($recipient);
            $mail-&gt;setSubject($subject);
            $mail-&gt;setBody($text);
	  
            // Посылаем эл. сообщение
            $transport = new Sendmail('-f'.$sender);
            $transport-&gt;send($mail);
            $result = true;
        } catch(\Exception $e) {
            $result = false;
        }
        
        // Возвращаем статус 
        return $result;
    }
}
</code></pre>
<p>В этом фрагменте мы определяем пространство имен <code>Application\Service</code> (строка 12), так как класс
<code>MailSender</code> можно отнести к моделям сервисов (его задачей является управление данными, а не их хранение).</p>
<p>В строках 4-6 мы объявляем псевдонимы для классов <code>Mail</code>, <code>Message</code> и <code>Transport\Sendmail</code>, предоставляемых
компонентом <code>Zend\Mail</code>.</p>
<p>В строках 9-35 мы определяем класс <code>MailSender</code>. У него есть один единственный метод <code>sendMail()</code> (строка 12),
который принимает четыре аргумента: адрес электронной почты отправителя, адрес электронной почты получателя,
тема сообщения и, наконец, основной текст сообщения.</p>
<p>В строке 18 мы создаем экземпляр класса <code>Message</code>. Мы используем методы этого класса, чтобы составить
сообщение (задать его тему, текст и т.д.) в строках 19-22.</p>
<p>В строке 25 мы создаем экземпляр класса <code>Sendmail</code>, который использует программу <em>sendmail</em> для передачи
сообщения почтовому серверу (см. строки 25-26). Так как классы, предоставляемые компонентом <code>Zend\Mail</code> могут
выбрасывать исключение при ошибке, мы заключим этот фрагмент кода в блок обработки исключений try-catch</p>
<p>Метод <code>sendMail()</code> вернет значение <code>true</code>, если сообщение было успешно отправлено; в противном случае он вернет
<code>false</code> (строка 33).</p>
<blockquote class="notquote information" data-type="information"><p> Настройка почтовой системы для веб-сервера - это довольно сложная задача. Она, как правило,
 требует установки sendmail и настройки записи MX DNS сервера для использования определенного 
 почтового сервера (либо локального, например, <a href="http://www.postfix.org/">Posftix</a>, 
 либо удаленного вроде Google Mail). 
 Из-за сложности этой темы, мы не обсуждаем ее в данной книге. Вы можете 
 найти дополнительную информацию о настройки почты для вашей конкретной системы в Интернете.</p>
</blockquote><p>Теперь зарегистрируем сервис <code>MailSender</code> в файле <code>module.config.php</code> следующим образом:</p>
<pre class=""><code class="language-php">return [
    //...
    'service_manager' =&gt; [
        'factories' =&gt; [
            Service\MailSender::class =&gt; InvokableFactory::class,
        ],
    ],
    
    //...
];
</code></pre>
<p>Далее вы сможете инстанцировать модель <code>MailSender</code> в методе <code>IndexController::contactUsAction()</code> и передать ей
валидированные данные формы.</p>
<blockquote class="notquote information" data-type="information"><p> Так как мы используем сервис <code>MailSender</code> в нашем контроллере, этот сервис является <em>зависимостью</em> для контроллера.
 Таким образом, нам необходимо будет создать фабрику для контроллера и <em>внедрить</em> зависимость  в конструктор контроллера.
 Кажется сложным на первый взгляд, но когда вы улучшите свои навыки, то поймете, что это довольно просто и
 значительно улучшает структуру вашего кода.</p>
</blockquote><p>Давайте создадим фабрику для <code>IndexController</code> (поместим ее в подкаталог <code>Factory</code> под каталогом <code>Controller</code>).
Как видите, вся работа класса фабрики заключается в создании контроллера и передаче ему зависимости.</p>
<pre class=""><code class="language-php">&lt;?php
namespace Application\Controller\Factory;

use Interop\Container\ContainerInterface;
use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\MailSender;
use Application\Controller\IndexController;

class IndexControllerFactory
{
    public function __invoke(ContainerInterface $container, 
                             $requestedName, array $options = null)
    {
        $mailSender = $container-&gt;get(MailSender::class);
        
        // Instantiate the controller and inject dependencies
        return new IndexController($mailSender);
    }
}
</code></pre>
<p>Изменим файл <code>module.config.php</code>, чтобы он использовал только что созданную нами фабрику:</p>
<pre class=""><code class="language-php">return [
    //...
    'controllers' =&gt; [
        'factories' =&gt; [
            Controller\IndexController::class =&gt; Controller\Factory\IndexControllerFactory::class,
        ],
    ],
    
    //...
];
</code></pre>
<p>Затем добавим к контроллеру конструктор, а также методы <code>contactUsAction()</code>, <code>thankYouAction()</code> и<code>sendErrorAction()</code>.</p>
<pre class="line-numbers"><code class="language-php">&lt;?php
// ...
use Application\Service\MailSender;

class IndexController extends AbstractActionController 
{
    private $mailSender;
    
    public function __construct($mailSender) 
    {
        $this-&gt;mailSender = $mailSender;
    }
    
    public function contactUsAction() 
    {
        // Создаем форму обратной связи
        $form = new ContactForm();
        
        // Проверяем, отправил ли пользователь форму
        if($this-&gt;getRequest()-&gt;isPost()) {
            
            // Заполняем форму POST-данными
            $data = $this-&gt;params()-&gt;fromPost();            
            
            $form-&gt;setData($data);
            
            // Валидируем форму
            if($form-&gt;isValid()) {
                    
                // Получаем фильтрованные и валидированные данные
                $data = $form-&gt;getData();
                $email = $data['email'];
                $subject = $data['subject'];
                $body = $data['body'];
                    
                // Отправляем эл. почту
                if(!$this-&gt;mailSender-&gt;sendMail('no-reply@example.com', $email, 
                            $subject, $body)) {
                    // В случае ошибки перенаправляем на страницу "Ошибка отправки электронной почты"
                    return $this-&gt;redirect()-&gt;toRoute('application', 
                            ['action'=&gt;'sendError']);
                }
                    
                // Перенаправляем на страницу "Спасибо"
                return $this-&gt;redirect()-&gt;toRoute('application', 
                            ['action'=&gt;'thankYou']);
            }            
        } 
        
        // Передаем переменную формы представлению
        return new ViewModel([
            'form' =&gt; $form
        ]);
    }
    
    // Это действие отображает страницу благодарности. Пользователь перенаправляется на эту
    // страницу при успешной отправке письма.
    public function thankYouAction() 
    {
        return new ViewModel();
    }
    
    // Это действие отображает страницу ошибки. Пользователь перенаправляется на эту
    // страницу в случае ошибки при отправке письма.
    public function sendErrorAction() 
    {
        return new ViewModel();
    }
}
</code></pre>
<p>Как вы видите из фрагмента кода выше, мы делаем следующее:</p>
<ul>
<li><p>В строке 3 мы определяем псевдоним для класса <code>Application\Service\MailSender</code>.
Это позволит ссылаться на класс модели по его короткому имени.</p>
</li>
<li><p>В строках 32-34, после валидации формы, мы извлекаем валидированные значениями
полей в PHP-переменные <code>$email</code>, <code>$subject</code> и <code>$body</code>.</p>
</li>
<li><p>В строке 37 мы вызываем метод <code>sendMail()</code> сервиса <code>MailSender</code> и передаем ему
четыре параметра: адрес отправителя (в примере мы используем "no-reply@example.com", но
вы можете заменить его своим); адрес электронной почты получателя, тему электронного
сообщение и его основной текст.</p>
</li>
<li><p>Если письмо было успешно отправлено (если метод <code>sendMail() вернул значение </code>true<code>), мы
перенаправляем пользователя на страницу *Thank You* (строка 45). В случае ошибки (если
метод </code>sendMail() вернул значение <code>false</code>) пользователь перенаправляется на страницу
<em>Send Error</em> (строка 40).</p>
</li>
<li><p>В строках 58-61 находится метод <code>thankYouAction()</code>, отображающий страницу благодарности.
Эта страница показывается при успешной отправке письма.</p>
</li>
<li><p>В строках 65-68 находится метод <code>sendErrorAction()</code>, отображающий страницу ошибки отправки письма.
Эта страница показывается при неудачной отправке.</p>
</li>
</ul>
        
</div>

<!-- Ads -->
<div id="ads-chapter-bottom">
<div>
﻿<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Using Zend Framework 3 Chapter - Bottom - Adaptive -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-3933778336056438"
     data-ad-slot="1546211126"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
</div>
    
<!-- Navigation -->
<div class="navigation">
        <div class="current-chapter">
        <a href="../Cбор_пользовательских_данных_с_помощью_форм.html">
            <img alt="Contents" src="../../assets/images/upload.png"><span class="nav-btn-text">Cбор пользовательских данных с помощью форм</span>
        </a>
    </div>
        <div class="prev-chapter">
        
        <a href="../Cбор_пользовательских_данных_с_помощью_форм/Добавление_правил_валидации_формы.html">
            <img alt="Previous Chapter" src="../../assets/images/left.png"><span class="nav-btn-text">Previous</span>
        </a>
        </div>    
    <div class="contents">
        <a href="../toc.html">
            <img alt="Contents" src="../../assets/images/book.png"><span class="nav-btn-text">Contents</span>
        </a>
    </div>
    <div class="next-chapter">
                <a href="../Cбор_пользовательских_данных_с_помощью_форм/Представление_формы.html">
            <span class="nav-btn-text">Next</span><img alt="Next Chapter" src="../../assets/images/right.png">
        </a>
            </div>        
</div>

<div id="disqus_thread"></div>

        
</div>
<footer>
    <div class="footer">
        <div class="footer-body">
            <div class="copyright">
                Copyright (c) 2017 by Oleg Krivtsov            </div>
            <div class="generated-by">
                Generated using <a href="https://github.com/olegkrivtsov/openbook">OpenBook</a>
            </div>
        </div>    
    </div>
</footer>

<a href="#0" class="cd-top">Top</a>

<script src="../../assets/js/jquery.min.js"></script>
<script src="../../assets/js/loadCSS.js"></script>

<script src="../../assets/js/prism.js"></script>

<script>
var disqus_config = function () {
this.page.url = window.location.href; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//using-zend-framework-3-book.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script>
loadCSS("../../assets/css/prism.css");
</script>

<script>
jQuery(document).ready(function($){
    // browser window scroll (in pixels) after which the "back to top" link is shown
    var offset = 300,
    //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
    offset_opacity = 1200,
    //duration of the top scrolling animation (in ms)
    scroll_top_duration = 700,
    //grab the "back to top" link
    $back_to_top = $('.cd-top');

    //hide or show the "back to top" link
    $(window).scroll(function(){
            ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
            if( $(this).scrollTop() > offset_opacity ) { 
                    $back_to_top.addClass('cd-fade-out');
            }
    });

    //smooth scroll to top
    $back_to_top.on('click', function(event){
            event.preventDefault();
            $('body,html').animate({
                    scrollTop: 0 ,
                    }, scroll_top_duration
            );
    });

});
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-80824388-1', 'auto');
  ga('send', 'pageview');

</script>

</body>
</html>    

